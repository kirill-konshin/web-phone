{"version":3,"file":"ringcentral-web-phone.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,CAAC;AACD,O;;;;;;;;;;;;;;ACVO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9EO;AACP,YAAY,+BAA+B;AAC3C,mBAAmB,sCAAsC;AACzD,kBAAkB,qCAAqC;AACvD,YAAY,2CAA2C;AACvD,eAAe,8BAA8B;AAC7C,aAAa,4BAA4B;AACzC,eAAe,8BAA8B;AAC7C,gBAAgB,+BAA+B;AAC/C,mBAAmB,mCAAmC;AACtD,cAAc,8BAA8B;AAC5C,sBAAsB,sCAAsC;AAC5D,wBAAwB,wCAAwC;AAChE;AACO;AACA;AACA;AACP;AACA;AACA;AACO;AACA;AACA;;;;;;;;;;;;;;;ACtBP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACtB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,yCAAyC,WAAW,kBAAkB,gBAAgB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS,kCAAkC,MAAM;AAC1F;AACA,qCAAqC,SAAS,0BAA0B,MAAM;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAsB;AACpD;AACA;AACA,yCAAyC,SAAS,+BAA+B,UAAU;AAC3F;AACA;AACA;AACwB;;;;;;;;;;;;;;;;;;AC3WoC;AAC1B;AAClC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+BAA+B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,yBAAyB,2DAAuB;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO,QAAQ,OAAO,UAAU,aAAa,MAAM,KAAK,gBAAgB,cAAc;AAC9I,oCAAoC,4BAA4B;AAChE;AACA;AACA,0BAA0B,6CAAS,oBAAoB,qDAAiB;AACxE;AACA;AACA;AACA;AACA;AACA,iBAAiB,gEAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,QAAQ;AAC5B,qBAAqB,SAAS;AAC9B,mBAAmB,QAAQ;AAC3B,yBAAyB,WAAW;AACpC,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,yCAAyC,KAAK,MAAM,kBAAkB;AACtE,2BAA2B,KAAK,MAAM,IAAI;AAC1C;AACA,sBAAsB,KAAK;AAC3B,6BAA6B,oBAAoB,QAAQ,mBAAmB;AAC5E,qBAAqB,QAAQ,SAAS,OAAO,WAAW,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,uBAAuB;AACvB;AACA;AACA;AACA;AACA,CAAC;AACD,0BAA0B;AAC1B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrPO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXsC;AACmB;AACP;AACU;AAC3B;AACuB;AACV;AACN;AACN;AACc;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,iBAAiB,mFAAyB;AAC1C,6BAA6B,gEAA2B;AACxD;AACA;AACA,iBAAiB,kFAAwB;AACzC;AACA;AACA,6BAA6B,+DAA0B;AACvD;AACA;AACA,iBAAiB,kFAAwB;AACzC;AACA;AACA,6BAA6B,+DAA0B;AACvD;AACA;AACA,iBAAiB,iFAAuB;AACxC;AACA,6BAA6B,8DAAyB;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8CAAM;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mCAAmC,+DAAuB;AAC1D;AACA;AACA;AACA,KAAK;AACL,0GAA0G,cAAc;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8CAAM;AACV;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW,oBAAoB,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,uDAAe;AACtC;AACA;AACA;AACA,0EAA0E,YAAY;AACtF;AACA,aAAa;AACb;AACA,sEAAsE,6BAA6B;AACnG,aAAa;AACb;AACA;AACA;AACA,kBAAkB,+DAAc;AAChC,uCAAuC,kBAAkB;AACzD,+CAA+C;AAC/C,aAAa;AACb;AACA,oBAAoB,iCAAiC;AACrD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA,cAAc,+DAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,2CAA2C;AAC3C,SAAS;AACT;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA,wEAAwE,uDAAe;AACvF;AACA;AACA,wEAAwE,4DAAoB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,OAAO,uEAA+B,QAAQ;AACxH;AACA;AACA,2CAA2C,qDAAa,IAAI,QAAQ;AACpE;AACA;AACA,2CAA2C,wDAAgB;AAC3D;AACA;AACA,2CAA2C,sDAAc;AACzD;AACA;AACA,2CAA2C,qDAAa;AACxD;AACA;AACA,uBAAuB,kFAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAoB;AACtC;AACA;AACA;AACA,uBAAuB,kFAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gCAAgC,uDAAY;AAC5C;AACA;AACA;AACA;AACA,qDAAqD,uBAAuB;AAC5E;AACA,gDAAgD,qDAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAS;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,mDAAmD,qDAAiB,QAAQ,OAAO,GAAG,8BAA8B;AACpH;AACA;AACA,gDAAgD,kBAAkB,oBAAoB;AACtF;AACA,mDAAmD,qDAAiB,QAAQ,OAAO,GAAG,8BAA8B;AACpH;AACA;AACA;AACA,4CAA4C,kBAAkB,oBAAoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM,YAAY,UAAU,gBAAgB,aAAa;AAC/F;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA,kBAAkB,4DAAuB;AACzC;AACA;AACA;AACA,sBAAsB,mEAA8B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAA0C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAM;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,8CAAM;AACd;AACA;AACA;AACA,2BAA2B,4DAAoB,GAAG,2DAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iCAAiC,uDAAmB;AACpD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI,6DAAuB;AAC3B;AACA,0DAA0D,aAAa,IAAI,cAAc,EAAE,uBAAuB;AAClH,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAA6B,4BAA4B,kEAA6B;AAC3G,qBAAqB,6DAAwB,4BAA4B,6DAAwB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1wBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qEAAqE,OAAO;AAC5E;AACA;AACA;AACA;AACA,wEAAwE,OAAO;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,mBAAmB,QAAQ,gBAAgB,IAAI,4BAA4B;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,KAAK;AAC/D;AACA;AACA;AACA;AACA,0GAA0G,MAAM;AAChH;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,kHAAkH,MAAM;AACxH;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uGAAuG,MAAM;AAC7G;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,MAAM;AACxH;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,YAAY;AACpG;AACA;AACA,0FAA0F,YAAY;AACtG;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0FAA0F,YAAY;AACtG;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,SAAS;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,SAAS;AAC9F;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,SAAS;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM,EAAE,QAAQ;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uBAAuB,sCAAsC;AAC7D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC74BsC;AACE;AACN;AAC3B;AACP;AACA;AACA;AACA,6BAA6B,gDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAyB;AAC1C,+BAA+B,gEAA2B;AAC1D;AACA;AACA,iBAAiB,4DAAwB;AACzC,+BAA+B,+DAA0B;AACzD;AACA;AACA;AACA,iBAAiB,gEAA4B;AAC7C,+BAA+B,mEAA8B;AAC7D;AACA;AACA,iBAAiB,+DAA2B;AAC5C,+BAA+B,kEAA6B;AAC5D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sEAAsE,aAAa,IAAI,UAAU;AACjG,kBAAkB,8EAAyC,MAAM;AACjE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2EAAsC;AAC5D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,YAAY;AACpF,sCAAsC,aAAa;AACnD;AACA,kBAAkB,uEAAkC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,aAAa,yBAAyB,0BAA0B;AAC7H;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,0DAA0D,+CAA+C;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,SAAS;AAC9E;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAkC;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClNsC;AAC8D;AAC9C;AACV;AACV;AACkF;AAC/D;AACrD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,4EAAkC;AAC1G,gBAAgB,8DAAoB;AACpC,gBAAgB,sEAA4B;AAC5C;AACA;AACA,+BAA+B,4DAAuB;AACtD,aAAa;AACb;AACA;AACA;AACA,mCAAmC,qEAAgC;AACnE;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B,6CAAS;AACnC,6BAA6B,gDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,GAAG,iBAAiB,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8CAAU;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gCAAgC,qDAAW;AAC3C;AACA,2BAA2B,mEAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kEAAkB;AACtB;AACA;AACA;AACA,iBAAiB,0DAAsB;AACvC,+BAA+B,6DAAwB;AACvD;AACA;AACA,iBAAiB,0DAAsB;AACvC,+BAA+B,6DAAwB;AACvD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB,8DAA0B;AAC3C,+BAA+B,gEAA2B;AAC1D;AACA;AACA,iBAAiB,gEAA4B;AAC7C,+BAA+B,kEAA6B;AAC5D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,0DAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB,WAAW,GAAG;AACnE,gBAAgB,qDAAiB;AACjC;AACA,yBAAyB,4CAAQ;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAmC;AAC7D;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,oCAAoC,0EAA0E;AAC9G,yDAAyD,sBAAsB;AAC/E;AACA;AACA;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4EAAkC;AAC7E;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,wBAAwB,2CAAO,OAAO,qDAAiB,QAAQ,OAAO,GAAG,oBAAoB;AAC7F;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAAuB;AACpD,aAAa;AACb;AACA,6BAA6B,4DAAuB;AACpD,aAAa;AACb,SAAS;AACT,KAAK;AACL,8BAA8B,gEAA2B;AACzD;AACA;AACA,yBAAyB,mEAA8B;AACvD;AACA;AACA,KAAK;AACL,IAAI,8DAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,qBAAqB,eAAe,SAAS,4BAA4B,WAAW,yBAAyB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrPsC;AACF;AACF;AAClC;AACO;AACP;AACA,6BAA6B,gDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qDAAQ;AACrB;AACA,2CAA2C,iBAAiB;AAC5D,sBAAsB,kEAA6B;AACnD;AACA;AACA,aAAa,mDAAM;AACnB;AACA;AACA;AACA,+CAA+C,iBAAiB;AAChE,0BAA0B,6DAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iBAAiB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxDO;AACP;AACA;AACA;AACA,CAAC;AACM,wBAAwB,UAAU,4BAA4B,WAAW;;;;;;;;;;;ACLhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,YAAY;AAC1E;AACA,8DAA8D,YAAY;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;;;;;;;;;;AChfA;;;;;;;;;;;;;;ACAA;AACA,IAAI,eAAe;AACnB;AACA;AACA,QAAQ,eAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mDAAmD;;;;;;;;;;;;;;;AC7CpD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,iCAAiC;;;;;;;;;;;;;;;;;;;;ACVqC;AACE;AACF;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,2BAA2B,gFAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kFAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gFAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrHmD;AACZ;AACvC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,eAAe,oDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAa;AACpC;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAS,aAAa,YAAY;AACvD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChIwD;AACxD;AACA;AACA;AACA;AACO,qCAAqC,iEAAe;AAC3D;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACTwD;AACxD;AACA;AACA;AACA;AACO,sCAAsC,iEAAe;AAC5D;AACA;AACA;AACA;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;;;;;;;;;;;;;;;;;ACrBgD;AACW;AAC9E;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,iDAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,4DAAiB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oDAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qDAAU;AACtD;AACA;AACA;AACA;AACA;AACA,gDAAgD,qDAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qDAAqD,EAAE;AACvD;;;;;;;;;;;;;;;;ACzIA;AACA;AACsD;AACtD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,YAAY,yDAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;;;;;;;;;;;;;;;;ACjDQ;AAC7C;AACA;AACA;AACA;AACO,6BAA6B,sDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtC2D;AACxB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,iCAAiC;AACjC,UAAU;AACV,iCAAiC;AACjC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,SAAS,IAAI;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC,wCAAG;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC,mCAAmC,wCAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA,uCAAuC,wCAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA,mCAAmC;AACnC;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,6BAA6B,gEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT,6BAA6B,uBAAuB,YAAY,yBAAyB;AACzF;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,+BAA+B,gEAAc;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,uBAAuB,YAAY,yBAAyB;AACrF;AACA,mCAAmC;AACnC;AACA,SAAS;AACT,iCAAiC,uBAAuB,YAAY,6BAA6B;AACjG;AACA,mCAAmC;AACnC,+BAA+B,gEAAc;AAC7C,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB,YAAY,6BAA6B;AAC3F;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB,YAAY,6BAA6B;AAC3F;AACA;AACA,4BAA4B,uBAAuB,YAAY,+BAA+B;AAC9F;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB,YAAY,4BAA4B;AACrF;AACA;AACA,sBAAsB,uBAAuB,YAAY,6BAA6B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA,mCAAmC;AACnC;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,6BAA6B,gEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,mCAAmC;AACnC,+BAA+B,gEAAc;AAC7C,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT,6BAA6B,WAAW;AACxC,gCAAgC,0BAA0B;AAC1D;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,+BAA+B,gEAAc;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,kDAAkD,uCAAuC;AACzF,qBAAqB,MAAM;AAC3B,iCAAiC;AACjC,oCAAoC,KAAK;AACzC,wBAAwB,KAAK,OAAO,2BAA2B,QAAQ;AACvE,qBAAqB;AACrB,uBAAuB,MAAM,KAAK,MAAM,mBAAmB;AAC3D,wBAAwB,QAAQ,YAAY,KAAK,MAAM,sBAAsB,KAAK,MAAM;AACxF,oCAAoC;AACpC;AACA;AACA,qBAAqB;AACrB,uBAAuB,sCAAsC,0HAA0H,sCAAsC;AAC7N,uBAAuB,qBAAqB,0HAA0H,qBAAqB;AAC3L,kGAAkG,4EAA4E,IAAI,oGAAoG,MAAM;AAC5R,uBAAuB,2RAA2R,sGAAsG,2RAA2R;AACnrB,sBAAsB,kBAAkB;AACxC,sBAAsB,kBAAkB;AACxC,sBAAsB,kBAAkB;AACxC,sBAAsB,kBAAkB;AACxC,sBAAsB,kBAAkB;AACxC,mCAAmC;AACnC,sBAAsB;AACtB,sBAAsB,kBAAkB,QAAQ;AAChD,sBAAsB,kBAAkB;AACxC,sBAAsB,kBAAkB,QAAQ;AAChD,sBAAsB,KAAK;AAC3B,sBAAsB,KAAK;AAC3B,sBAAsB,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,MAAM;AAC/D,iFAAiF,MAAM;AACvF,uBAAuB,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM;AACzD,sBAAsB,KAAK,OAAO,MAAM,KAAK,MAAM,aAAa;AAChE,qBAAqB,kBAAkB,0CAA0C;AACjF;AACA,sBAAsB,kBAAkB,YAAY;AACpD,sBAAsB,kBAAkB,YAAY,KAAK,KAAK;AAC9D;AACA,sBAAsB,mBAAmB,oCAAoC;AAC7E,sBAAsB,MAAM,MAAM,QAAQ,MAAM,MAAM;AACtD;AACA,uBAAuB,MAAM,2EAA2E,MAAM;AAC9G,sBAAsB,mBAAmB;AACzC,sBAAsB,MAAM,OAAO;AACnC,wBAAwB,kCAAkC,kCAAkC,GAAG;AAC/F;AACA;AACA,mCAAmC;AACnC,uBAAuB,wBAAwB,wBAAwB,qBAAqB,mBAAmB,kBAAkB,GAAG,eAAe,+FAA+F,wBAAwB,qBAAqB,mBAAmB,kBAAkB,GAAG,eAAe,2FAA2F,qBAAqB,mBAAmB,kBAAkB,GAAG,eAAe,gFAAgF,mBAAmB,kBAAkB,GAAG,eAAe,yEAAyE,kBAAkB,GAAG,eAAe,gEAAgE,GAAG,eAAe,wDAAwD,iDAAiD,2BAA2B,iCAAiC,qBAAqB,mBAAmB,kBAAkB,GAAG,eAAe,8DAA8D,sBAAsB,oDAAoD,mBAAmB,kBAAkB,GAAG,eAAe,0DAA0D,sBAAsB,4CAA4C,kDAAkD,kBAAkB,GAAG,eAAe,sDAAsD,sBAAsB,4CAA4C,yCAAyC,iDAAiD,GAAG,eAAe,kDAAkD,sBAAsB,4CAA4C,4CAA4C,yCAAyC,yBAAyB,wBAAwB,8CAA8C,sBAAsB,4CAA4C,4CAA4C,4CAA4C,yCAAyC,yBAAyB,wBAAwB,kDAAkD,wBAAwB,4CAA4C,4CAA4C,4CAA4C,4CAA4C,yCAAyC;AACx+E,sBAAsB,KAAK,YAAY,YAAY;AACnD,sBAAsB,GAAG,eAAe,wBAAwB;AAChE,sBAAsB,kBAAkB,kBAAkB,kBAAkB;AAC5E,uGAAuG,qBAAqB,+CAA+C,KAAK,4CAA4C,qBAAqB;AACjP,uBAAuB,YAAY,YAAY,YAAY,YAAY;AACvE,oCAAoC,kCAAkC;AACtE,qBAAqB,MAAM,IAAI,EAAE,MAAM,MAAM,MAAM,MAAM;AACzD,+EAA+E,0CAA0C;AACzH,kFAAkF;AAClF,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;AACzC,wDAAwD;AACxD,sBAAsB,mBAAmB;AACzC,uBAAuB,QAAQ;AAC/B,uBAAuB,QAAQ;AAC/B,qBAAqB,MAAM,MAAM;AACjC;AACA,mCAAmC,oBAAoB,kCAAkC;AACzF,sBAAsB,kBAAkB;AACxC,sBAAsB,MAAM,MAAM,QAAQ,MAAM,MAAM;AACtD,sBAAsB,MAAM,MAAM,KAAK,MAAM,MAAM;AACnD;AACA,qBAAqB,SAAS;AAC9B,sBAAsB,QAAQ,KAAK,KAAK,KAAK;AAC7C,qBAAqB,MAAM;AAC3B,sBAAsB,qBAAqB,MAAM;AACjD,sBAAsB,MAAM,mBAAmB;AAC/C,4CAA4C,QAAQ;AACpD,oCAAoC;AACpC,sBAAsB,MAAM,KAAK;AACjC,qBAAqB,MAAM,MAAM;AACjC,qBAAqB,SAAS,qBAAqB,uCAAuC;AAC1F,sBAAsB,oBAAoB,kCAAkC;AAC5E,uBAAuB,KAAK,sBAAsB,kCAAkC;AACpF,sBAAsB,KAAK;AAC3B,qBAAqB,MAAM,6BAA6B;AACxD,uBAAuB,UAAU,OAAO,+CAA+C,OAAO;AAC9F,qBAAqB,SAAS;AAC9B,uBAAuB,cAAc,0BAA0B;AAC/D,sBAAsB,SAAS,IAAI,mEAAmE,uDAAuD,SAAS,IAAI,mEAAmE;AAC7O,sBAAsB,KAAK;AAC3B,uDAAuD,QAAQ,uBAAuB,QAAQ;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS,SAAS,SAAS,SAAS,SAAS,OAAO,EAAE,SAAS,SAAS,SAAS,SAAS;AAChH,sBAAsB,QAAQ,KAAK,QAAQ,KAAK;AAChD,sBAAsB;AACtB,sBAAsB,KAAK,KAAK;AAChC,uBAAuB,MAAM,IAAI,EAAE,MAAM,MAAM,MAAM,MAAM,KAAK,MAAM,IAAI,EAAE,MAAM,MAAM,MAAM,MAAM;AACpG,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,sBAAsB,eAAe,IAAI;AACzC,sBAAsB,OAAO,UAAU,KAAK,wBAAwB,KAAK;AACzE,sBAAsB,MAAM,UAAU,KAAK,wBAAwB,KAAK;AACxE,sBAAsB,eAAe,KAAK,KAAK;AAC/C,uBAAuB,OAAO,KAAK,qBAAqB,KAAK,qCAAqC;AAClG,qBAAqB,SAAS,SAAS;AACvC,yCAAyC,KAAK;AAC9C,yCAAyC,KAAK;AAC9C,uBAAuB,QAAQ;AAC/B,0DAA0D,YAAY,YAAY;AAClF,sBAAsB,MAAM,KAAK;AACjC,qBAAqB,MAAM,MAAM;AACjC,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,8DAA8D,kDAAkD;AAChH,qBAAqB,SAAS;AAC9B,6CAA6C,qDAAqD;AAClG,sBAAsB,OAAO,KAAK,qBAAqB,KAAK;AAC5D,uBAAuB,QAAQ;AAC/B,sBAAsB;AACtB,sBAAsB,SAAS,IAAI,UAAU,KAAK,wBAAwB,KAAK;AAC/E,qBAAqB,SAAS;AAC9B,2FAA2F,kDAAkD;AAC7I,qEAAqE;AACrE,qBAAqB,MAAM;AAC3B,8CAA8C;AAC9C,qBAAqB,SAAS;AAC9B,sBAAsB,KAAK,KAAK;AAChC,qBAAqB,MAAM;AAC3B,sBAAsB,QAAQ,KAAK;AACnC,uBAAuB,QAAQ;AAC/B,sBAAsB;AACtB,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,uBAAuB,oBAAoB,kCAAkC;AAC7E,sBAAsB,MAAM,UAAU,KAAK,wBAAwB,KAAK;AACxE,qBAAqB,SAAS;AAC9B,6CAA6C,KAAK;AAClD,uBAAuB,QAAQ;AAC/B,sBAAsB;AACtB,uBAAuB,QAAQ,SAAS,KAAK,KAAK,OAAO,KAAK,wBAAwB,KAAK;AAC3F,qBAAqB;AACrB,6CAA6C,KAAK,UAAU,KAAK,wBAAwB,KAAK,+CAA+C;AAC7I,sBAAsB,KAAK,KAAK,UAAU,KAAK,wBAAwB,KAAK;AAC5E,sBAAsB,GAAG,EAAE,KAAK,MAAM;AACtC,qBAAqB,SAAS,SAAS,OAAO,EAAE,SAAS,SAAS,SAAS,SAAS;AACpF,6CAA6C,KAAK;AAClD,sBAAsB;AACtB,gDAAgD,QAAQ,QAAQ,WAAW,QAAQ,SAAS,yBAAyB,QAAQ,SAAS,wBAAwB;AAC9J,qBAAqB,MAAM;AAC3B,6CAA6C,KAAK;AAClD,sBAAsB;AACtB,6CAA6C,KAAK;AAClD,6CAA6C;AAC7C,6CAA6C,qDAAqD;AAClG,gDAAgD,QAAQ,SAAS,uBAAuB,qCAAqC,uCAAuC;AACpK,sEAAsE;AACtE,sBAAsB,OAAO,KAAK,qBAAqB,KAAK;AAC5D,sBAAsB,QAAQ,KAAK,QAAQ,KAAK;AAChD,uBAAuB,QAAQ;AAC/B,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,sBAAsB,MAAM,UAAU,YAAY,KAAK,gCAAgC,KAAK,wBAAwB,KAAK;AACzH,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,sBAAsB;AACtB,6CAA6C,KAAK,0DAA0D,KAAK,0EAA0E;AAC3L,uBAAuB,OAAO,KAAK,kCAAkC,KAAK;AAC1E,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,uBAAuB,QAAQ;AAC/B,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,4CAA4C,kDAAkD;AAC9F,6CAA6C,KAAK,mCAAmC,sBAAsB,KAAK,6DAA6D,KAAK,qCAAqC;AACvN,2IAA2I,kDAAkD;AAC7L,qBAAqB;AACrB,uBAAuB,OAAO,KAAK,kCAAkC,KAAK;AAC1E,sBAAsB,MAAM,UAAU,KAAK,wBAAwB,KAAK;AACxE,qBAAqB,SAAS;AAC9B,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,sBAAsB,QAAQ,KAAK,UAAU,KAAK,wBAAwB,KAAK;AAC/E,qBAAqB,OAAO,EAAE,SAAS,SAAS,SAAS,SAAS;AAClE,6CAA6C,KAAK;AAClD,6CAA6C,KAAK;AAClD,6CAA6C,KAAK,OAAO,MAAM;AAC/D,6CAA6C,KAAK;AAClD,6CAA6C,MAAM,KAAK;AACxD,sBAAsB,SAAS,IAAI,MAAM,IAAI;AAC7C,0CAA0C;AAC1C,gEAAgE,8CAA8C;AAC9G,sBAAsB,SAAS,KAAK;AACpC,sBAAsB,MAAM,OAAO;AACnC,uBAAuB,YAAY,YAAY,YAAY,YAAY;AACvE,uBAAuB,KAAK,YAAY;AACxC,qBAAqB;AACrB,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,qBAAqB,SAAS;AAC9B,kDAAkD;AAClD,sBAAsB,UAAU,KAAK,wBAAwB,KAAK;AAClE,sBAAsB,KAAK,KAAK;AAChC,sBAAsB,MAAM,MAAM,KAAK,MAAM,MAAM;AACnD,sBAAsB,KAAK;AAC3B,sBAAsB,MAAM,eAAe;AAC3C;AACA,sBAAsB,sBAAsB;AAC5C,sBAAsB,OAAO,MAAM;AACnC,qBAAqB,OAAO;AAC5B,mEAAmE;AACnE,sBAAsB,uBAAuB,qCAAqC;AAClF;AACA,+DAA+D,KAAK;AACpE,sBAAsB,0BAA0B,uBAAuB,uBAAuB,uBAAuB;AACrH,sBAAsB,KAAK,KAAK,KAAK;AACrC,sBAAsB,UAAU;AAChC,sBAAsB,UAAU,UAAU;AAC1C,sBAAsB,MAAM,KAAK,QAAQ,IAAI;AAC7C,+EAA+E,KAAK,YAAY,KAAK,WAAW,wBAAwB,KAAK,WAAW;AACxJ,qBAAqB,SAAS;AAC9B,kDAAkD,KAAK;AACvD,sBAAsB,KAAK,cAAc,EAAE,EAAE,MAAM,KAAK;AACxD;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qCAAqC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;AC/+CP;AAC6C;AAC7C;AACA;AACA;AACA;AACO,kBAAkB,sDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB;AAChB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;UC7SA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;;;ACNiE;AACxB;AACa;AACqB;AACpC;AACoF;AAC3C;AAC9C;AAClC,gBAAgB,kDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,4CAAI;AACd,WAAW;AACX;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,kBAAkB,wCAAI;AACtB;AACA,oBAAoB,0CAAM;AAC1B,0BAA0B,qDAAY;AACtC,8BAA8B,2DAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,eAAe;AACpD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,2BAA2B,iDAAa;AACxC,2BAA2B,0DAAsB;AACjD;AACA;AACA,2BAA2B,mDAAe;AAC1C;AACA;AACA,mDAAmD,0DAAkB;AACrE;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA,6DAA6D,KAAK;AAClE,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,wFAAgC;AAC7H;AACA;AACA,cAAc,4DAAoB;AAClC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAiB,QAAQ,sBAAsB,GAAG,oBAAoB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,8DAAS,sBAAsB,uDAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAuB;AAChD;AACA","sources":["webpack://RingCentral.WebPhone/webpack/universalModuleDefinition","webpack://RingCentral.WebPhone/./src/audioHelper.ts","webpack://RingCentral.WebPhone/./src/constants.ts","webpack://RingCentral.WebPhone/./src/events.ts","webpack://RingCentral.WebPhone/./src/mediaStreams.ts","webpack://RingCentral.WebPhone/./src/qos.ts","webpack://RingCentral.WebPhone/./src/rtpReport.ts","webpack://RingCentral.WebPhone/./src/session.ts","webpack://RingCentral.WebPhone/./src/sessionDescriptionHandler.ts","webpack://RingCentral.WebPhone/./src/transport.ts","webpack://RingCentral.WebPhone/./src/userAgent.ts","webpack://RingCentral.WebPhone/./src/userAgentCore.ts","webpack://RingCentral.WebPhone/./src/utils.ts","webpack://RingCentral.WebPhone/./node_modules/events/events.js","webpack://RingCentral.WebPhone/external umd {\"commonjs\":\"sip.js\",\"commonjs2\":\"sip.js\",\"amd\":\"sip.js\",\"root\":\"SIP\"}","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/api/session-state.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/core/log/levels.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/core/messages/body.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/core/messages/incoming-message.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/core/messages/incoming-request-message.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/core/messages/incoming-response-message.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/core/messages/methods/constants.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/core/messages/outgoing-request-message.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/core/messages/utils.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/grammar/grammar.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/grammar/name-addr-header.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/grammar/parameters.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/grammar/pegjs/dist/grammar.js","webpack://RingCentral.WebPhone/./node_modules/sip.js/lib/grammar/uri.js","webpack://RingCentral.WebPhone/webpack/bootstrap","webpack://RingCentral.WebPhone/webpack/runtime/compat get default export","webpack://RingCentral.WebPhone/webpack/runtime/define property getters","webpack://RingCentral.WebPhone/webpack/runtime/hasOwnProperty shorthand","webpack://RingCentral.WebPhone/webpack/runtime/make namespace object","webpack://RingCentral.WebPhone/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"sip.js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"sip.js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RingCentral\"] = factory(require(\"sip.js\"));\n\telse\n\t\troot[\"RingCentral\"] = root[\"RingCentral\"] || {}, root[\"RingCentral\"][\"WebPhone\"] = factory(root[\"SIP\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE_sip_js__) => {\nreturn ","export class AudioHelper {\n    /** Current volume */\n    volume;\n    _enabled;\n    _incoming;\n    _outgoing;\n    _audio;\n    constructor(options = {}) {\n        this._enabled = !!options.enabled;\n        this.loadAudio(options);\n    }\n    /** Load incoming and outgoing audio files for feedback */\n    loadAudio(options) {\n        this._incoming = options.incoming;\n        this._outgoing = options.outgoing;\n        this._audio = {};\n    }\n    /** Set volume for incoming and outgoing feedback */\n    setVolume(_volume) {\n        let volume = _volume;\n        if (volume < 0) {\n            volume = 0;\n        }\n        if (volume > 1) {\n            volume = 1;\n        }\n        this.volume = volume;\n        for (const url in this._audio) {\n            if (Object.hasOwn(this._audio, url)) {\n                this._audio[url].volume = volume;\n            }\n        }\n    }\n    /**\n     * Play or pause incoming feedback\n     * @param value `true` to play audio and `false` to pause\n     * @returns\n     */\n    playIncoming(value) {\n        return this._playSound(this._incoming, value, this.volume || 0.5);\n    }\n    /**\n     * Play or pause outgoing feedback\n     * @param value `true` to play audio and `false` to pause\n     * @returns\n     */\n    playOutgoing(value) {\n        return this._playSound(this._outgoing, value, this.volume || 1);\n    }\n    _playSound(url, val, volume) {\n        if (!this._enabled || !url || !this._audio) {\n            return this;\n        }\n        if (!this._audio[url]) {\n            if (val) {\n                this._audio[url] = new Audio();\n                this._audio[url].src = url;\n                this._audio[url].loop = true;\n                this._audio[url].volume = volume;\n                this._audio[url].playPromise = this._audio[url].play();\n            }\n        }\n        else {\n            if (val) {\n                this._audio[url].currentTime = 0;\n                this._audio[url].playPromise = this._audio[url].play();\n            }\n            else {\n                const audio = this._audio[url];\n                if (audio.playPromise !== undefined) {\n                    audio.playPromise.then(() => {\n                        audio.pause();\n                    });\n                }\n            }\n        }\n        return this;\n    }\n}\n","export const messages = {\n    park: { reqid: 1, command: 'callpark' },\n    startRecord: { reqid: 2, command: 'startcallrecord' },\n    stopRecord: { reqid: 3, command: 'stopcallrecord' },\n    flip: { reqid: 3, command: 'callflip', target: '' },\n    monitor: { reqid: 4, command: 'monitor' },\n    barge: { reqid: 5, command: 'barge' },\n    whisper: { reqid: 6, command: 'whisper' },\n    takeover: { reqid: 7, command: 'takeover' },\n    toVoicemail: { reqid: 11, command: 'toVoicemail' },\n    ignore: { reqid: 12, command: 'ignore' },\n    receiveConfirm: { reqid: 17, command: 'receiveConfirm' },\n    replyWithMessage: { reqid: 14, command: 'replyWithMessage' },\n};\nexport const uuidKey = 'rc-webPhone-uuid';\nexport const responseTimeout = 60000;\nexport const defaultMediaConstraints = {\n    audio: true,\n    video: false,\n};\nexport const defaultStunServers = ['stun.l.google.com:19302'];\nexport const defaultSipErrorCodes = ['408', '502', '503', '504'];\nexport const defaultLogLevel = 'debug';\n","/** @ignore */\nexport const Events = {\n    Transport: {\n        Connecting: 'connecting',\n        Connected: 'connected',\n        Disconnecting: 'disconnecting',\n        Disconnected: 'disconnected',\n        ConnectionAttemptFailure: 'wsConnectionError',\n        ConnectionFailure: 'transportError',\n        SwitchBackToMainProxy: 'switchBackProxy',\n        Closed: 'closed',\n    },\n    UserAgent: {\n        Registered: 'registered',\n        Unregistered: 'unregistered',\n        RegistrationFailed: 'registrationFailed',\n        InviteSent: 'inviteSent',\n        Invite: 'invite',\n        ProvisionUpdate: 'provisionUpdate',\n        Started: 'started',\n        Stopped: 'stopped',\n    },\n    Session: {\n        Accepted: 'accepted',\n        Progress: 'progress',\n        Muted: 'muted',\n        Unmuted: 'unmuted',\n        Establishing: 'establishing',\n        Established: 'established',\n        Terminating: 'terminating',\n        Terminated: 'terminated',\n        UpdateReceived: 'updateReceived',\n        MoveToRcv: 'moveToRcv',\n        QOSPublished: 'qos-published',\n        RTPStat: 'rtpStat',\n        UserMediaFailed: 'userMediaFailed',\n    },\n};\n","/*\n * @Author: Elias Sun(elias.sun@ringcentral.com)\n * @Date: Dec. 15, 2018\n * Copyright © RingCentral. All rights reserved.\n */\nimport { Events } from './events';\nvar ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[\"new\"] = \"mediaConnectionStateNew\";\n    ConnectionState[\"checking\"] = \"mediaConnectionStateChecking\";\n    ConnectionState[\"connected\"] = \"mediaConnectionStateConnected\";\n    ConnectionState[\"completed\"] = \"mediaConnectionStateCompleted\";\n    ConnectionState[\"failed\"] = \"mediaConnectionStateFailed\";\n    ConnectionState[\"disconnected\"] = \"mediaConnectionStateDisconnected\";\n    ConnectionState[\"closed\"] = \"mediaConnectionStateClosed\";\n})(ConnectionState || (ConnectionState = {}));\nexport var Browsers;\n(function (Browsers) {\n    Browsers[\"MSIE\"] = \"IE\";\n    Browsers[\"Chrome\"] = \"Chrome\";\n    Browsers[\"Firefox\"] = \"Firefox\";\n    Browsers[\"Safari\"] = \"Safari\";\n    Browsers[\"Opera\"] = \"Opera\";\n})(Browsers || (Browsers = {}));\nexport class WebPhoneRTPReport {\n    outboundRtpReport = {};\n    inboundRtpReport = {};\n    rttMs = {};\n    localCandidates = [];\n    remoteCandidates = [];\n    transport = {};\n}\n/** Media Streams class to monitor media stats */\nexport default class MediaStreams {\n    /**\n     * Reference to MediaStreamsImpl object. This Object has all the functions to handle media streams\n     *\n     * MediaStreams class is a wrapper around MediaStreamsImpl\n     */\n    mediaStreamsImpl;\n    /** Remove iceconnectionstatechange event listeners and stop collecting stats */\n    release;\n    /**\n     * Reconnect media and send reinvite on the existing session.\n     *\n     * This will also recreate SDP and send it over with the reinvite message\n     */\n    reconnectMedia;\n    /**\n     * @param callback function which will be called every time media stats are generated. Will override callback passed to `onRTPStat`\n     * @param interval interval for the recurring call to the callback function\n     * @returns\n     */\n    getMediaStats;\n    /** Stop collecting stats */\n    stopMediaStats;\n    constructor(session) {\n        this.mediaStreamsImpl = new MediaStreamsImpl(session);\n        this.release = this.mediaStreamsImpl.release.bind(this.mediaStreamsImpl);\n        this.reconnectMedia = this.mediaStreamsImpl.reconnectMedia.bind(this.mediaStreamsImpl);\n        this.getMediaStats = this.mediaStreamsImpl.getMediaStats.bind(this.mediaStreamsImpl);\n        this.stopMediaStats = this.mediaStreamsImpl.stopMediaStats.bind(this.mediaStreamsImpl);\n    }\n    /**\n     * Set a function to be called when media stats are generated\n     * @param callback optionally, you can set a function on MediaStreams object. This will be treated as a default callback when media stats are generated if a callback function is not passed with `getMediaStats` function\n     */\n    set onRTPStat(callback) {\n        this.mediaStreamsImpl.onRTPStat = callback;\n    }\n    get onRTPStat() {\n        return this.mediaStreamsImpl.onRTPStat;\n    }\n    /**\n     * Set a function to be called when `peerConnetion` iceconnectionstatechange changes\n     * @param callback function to be called when `peerConnetion` iceconnectionstatechange changes\n     */\n    set onMediaConnectionStateChange(callback) {\n        this.mediaStreamsImpl.onMediaConnectionStateChange = callback;\n    }\n    get onMediaConnectionStateChange() {\n        return this.mediaStreamsImpl.onMediaConnectionStateChange;\n    }\n}\n/**\n * MediaStreams Implementation\n */\nexport class MediaStreamsImpl {\n    preRTT;\n    /**\n     * Set a function to be called when `peerConnection` iceconnectionstatechange changes\n     *\n     * @param callback function to be called when `peerConnection` iceconnectionstatechange changes\n     */\n    onMediaConnectionStateChange;\n    /**\n     * Set a function to be called when media stats are generated\n     * @param callback optionally, you can set a function on MediaStreams object. This will be treated as a default callback when media stats are generated if a callback function is not passed with `getMediaStats` function\n     */\n    onRTPStat;\n    ktag = 'MediaStreams';\n    session;\n    isChrome;\n    isFirefox;\n    isSafari;\n    mediaStatsTimer;\n    constructor(session) {\n        this.ktag = 'MediaStreams';\n        if (!session) {\n            throw new Error(`${this.ktag}: Cannot initial media stream monitoring. Session is not passed`);\n        }\n        this.session = session;\n        this.onMediaConnectionStateChange = undefined;\n        this.onPeerConnectionStateChange = this.onPeerConnectionStateChange.bind(this);\n        const sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n        sessionDescriptionHandler.peerConnection.addEventListener('iceconnectionstatechange', this.onPeerConnectionStateChange);\n        this.isChrome = this.browser() === Browsers.Chrome;\n        this.isFirefox = this.browser() === Browsers.Firefox;\n        this.isSafari = this.browser() === Browsers.Safari;\n        this.preRTT = { currentRoundTripTime: 0 };\n        if (!this.isChrome && !this.isFirefox && !this.isSafari) {\n            this.session.logger.error(`${this.ktag} The web browser ${this.browser()} is not in the recommended list [Chrome, Safari, Firefox] !`);\n        }\n    }\n    /**\n     * @param callback function which will be called every time media stats are generated. Will override callback passed to `onRTPStat`\n     * @param interval interval for the recurring call to the callback function\n     * @returns\n     */\n    getMediaStats(callback, interval = 1000) {\n        if (!this.onRTPStat && !callback) {\n            this.session.logger.debug(`${this.ktag}: No event callback provided to call when media starts are generated`);\n            return;\n        }\n        if (callback) {\n            this.onRTPStat = callback;\n        }\n        if (this.mediaStatsTimer) {\n            clearTimeout(this.mediaStatsTimer);\n            this.mediaStatsTimer = null;\n        }\n        this.mediaStatsTimer = setInterval(() => {\n            this.mediaStatsTimerCallback();\n        }, interval);\n    }\n    /**\n     * Stop collecting stats. This will stop calling the registered function (either that was registered using `onRTPstat` or using `getMediaStats`)\n     */\n    stopMediaStats() {\n        if (this.mediaStatsTimer) {\n            clearTimeout(this.mediaStatsTimer);\n            this.onRTPStat = undefined;\n        }\n    }\n    /**\n     * Reconnect media and send reinvite on the existing session.\n     *\n     * This will also recreate SDP and send it over with the reinvite message\n     */\n    reconnectMedia() {\n        return new Promise((resolve, reject) => {\n            this.session.reinvite()\n                .then(() => resolve())\n                .catch(reject);\n        });\n    }\n    /**\n     * Remove iceconnectionstatechange event listeners and stop collecting stats\n     */\n    release() {\n        if (this.mediaStatsTimer) {\n            clearTimeout(this.mediaStatsTimer);\n            this.mediaStatsTimer = null;\n        }\n        const sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n        if (!sessionDescriptionHandler.peerConnection) {\n            return;\n        }\n        sessionDescriptionHandler.peerConnection.removeEventListener('iceconnectionstatechange', this.onPeerConnectionStateChange);\n    }\n    get tag() {\n        return this.ktag;\n    }\n    /**\n     * Function to find what browser is being used depending on the `navigator.userAgent` value\n     * @returns Browsers enum value to denote what browser if being used\n     */\n    browser() {\n        if (navigator.userAgent.search('MSIE') >= 0) {\n            return Browsers.MSIE;\n        }\n        else if (navigator.userAgent.search('Chrome') >= 0) {\n            return Browsers.Chrome;\n        }\n        else if (navigator.userAgent.search('Firefox') >= 0) {\n            return Browsers.Firefox;\n        }\n        else if (navigator.userAgent.search('Safari') >= 0 && navigator.userAgent.search('Chrome') < 0) {\n            return Browsers.Safari;\n        }\n        else if (navigator.userAgent.search('Opera') >= 0) {\n            return Browsers.Opera;\n        }\n        return 'unknown';\n    }\n    mediaStatsTimerCallback() {\n        const sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n        const peerConnection = sessionDescriptionHandler.peerConnection;\n        if (!peerConnection) {\n            this.session.logger.error(`${this.ktag}: The peer connection cannot be null`);\n            return;\n        }\n        const connectionState = peerConnection.iceConnectionState;\n        if (connectionState !== 'connected' && connectionState !== 'completed') {\n            this.preRTT.currentRoundTripTime = 0;\n            return;\n        }\n        this.getRTPReport(new WebPhoneRTPReport());\n    }\n    onPeerConnectionStateChange() {\n        let eventName = 'unknown';\n        const sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n        const state = sessionDescriptionHandler.peerConnection.iceConnectionState;\n        if (Object.hasOwn(ConnectionState, state)) {\n            eventName = ConnectionState[state];\n            if (this.onMediaConnectionStateChange) {\n                this.onMediaConnectionStateChange(eventName, this.session);\n            }\n            this.session.emit(eventName);\n        }\n        else {\n            this.session.logger.debug(`${this.tag}: Unknown peerConnection state: ${state}`);\n        }\n        this.session.logger.debug(`${this.tag}: peerConnection State: ${state}`);\n    }\n    async getRTPReport(report) {\n        const sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n        const peerConnection = sessionDescriptionHandler.peerConnection;\n        try {\n            const stats = await peerConnection.getStats();\n            stats.forEach((stat) => {\n                switch (stat.type) {\n                    case 'inbound-rtp':\n                        Object.keys(stat).forEach((statName) => {\n                            switch (statName) {\n                                case 'bytesReceived':\n                                case 'packetsReceived':\n                                case 'jitter':\n                                case 'packetsLost':\n                                case 'fractionLost':\n                                case 'mediaType':\n                                    report.inboundRtpReport[statName] = stat[statName];\n                                    break;\n                                case 'roundTripTime':\n                                    report.rttMs[statName] = stat[statName];\n                                    break;\n                            }\n                        });\n                        break;\n                    case 'outbound-rtp':\n                        Object.keys(stat).forEach((statName) => {\n                            switch (statName) {\n                                case 'bytesSent':\n                                case 'packetsSent':\n                                case 'mediaType':\n                                    report.outboundRtpReport[statName] = stat[statName];\n                                    break;\n                            }\n                        });\n                        break;\n                    case 'candidate-pair':\n                        Object.keys(stat).forEach((statName) => {\n                            switch (statName) {\n                                case 'currentRoundTripTime':\n                                    report.rttMs[statName] = stat[statName];\n                                    break;\n                            }\n                        });\n                        break;\n                    case 'local-candidate': {\n                        const local_candidate = {};\n                        Object.keys(stat).forEach((statName) => {\n                            switch (statName) {\n                                case 'id':\n                                case 'isRemote':\n                                case 'ip':\n                                case 'candidateType':\n                                case 'networkType':\n                                case 'priority':\n                                case 'port':\n                                    local_candidate[statName] = stat[statName];\n                                    break;\n                            }\n                        });\n                        report.localCandidates.push(local_candidate);\n                        break;\n                    }\n                    case 'remote-candidate': {\n                        const remote_candidate = {};\n                        Object.keys(stat).forEach((statName) => {\n                            switch (statName) {\n                                case 'id':\n                                case 'isRemote':\n                                case 'ip':\n                                case 'priority':\n                                case 'port':\n                                case 'candidateType':\n                                    remote_candidate[statName] = stat[statName];\n                                    break;\n                            }\n                        });\n                        report.remoteCandidates.push(remote_candidate);\n                        break;\n                    }\n                    case 'media-source':\n                        report.outboundRtpReport.rtpLocalAudioLevel = stat.audioLevel ? stat.audioLevel : 0;\n                        break;\n                    case 'track':\n                        if (!stat.remoteSource) {\n                            break;\n                        }\n                        report.inboundRtpReport.rtpRemoteAudioLevel = stat.audioLevel ? stat.audioLevel : 0;\n                        break;\n                    case 'transport':\n                        Object.keys(stat).forEach((statName) => {\n                            switch (statName) {\n                                case 'dtlsState':\n                                case 'packetsSent':\n                                case 'packetsReceived':\n                                case 'selectedCandidatePairChanges':\n                                case 'selectedCandidatePairId':\n                                    report.transport[statName] = stat[statName];\n                                    break;\n                            }\n                        });\n                        break;\n                    default:\n                        break;\n                }\n            });\n            if (!Object.hasOwn(report.rttMs, 'currentRoundTripTime')) {\n                if (!Object.hasOwn(report.rttMs, 'roundTripTime')) {\n                    report.rttMs.currentRoundTripTime = this.preRTT.currentRoundTripTime;\n                }\n                else {\n                    report.rttMs.currentRoundTripTime = report.rttMs.roundTripTime; // for Firefox\n                    delete report.rttMs.roundTripTime;\n                }\n            }\n            else {\n                report.rttMs.currentRoundTripTime = Math.round(report.rttMs.currentRoundTripTime * 1000);\n            }\n            if (Object.hasOwn(report.rttMs, 'currentRoundTripTime')) {\n                this.preRTT.currentRoundTripTime = report.rttMs.currentRoundTripTime;\n            }\n            this.onRTPStat(report, this.session);\n            this.session.emit(Events.Session.RTPStat, report);\n        }\n        catch (e) {\n            this.session.logger.error(`${this.tag}: Unable to get media stats: ${e.message}`);\n        }\n    }\n}\nexport { MediaStreams };\n","import { SessionState, Publisher, UserAgent } from 'sip.js';\nimport { Events } from './events';\nconst formatFloat = (input) => parseFloat(input.toString()).toFixed(2);\nexport const startQosStatsCollection = (session) => {\n    const qosStatsObj = getQoSStatsTemplate();\n    qosStatsObj.callID = session.request.callId || '';\n    qosStatsObj.fromTag = session.request.fromTag || '';\n    qosStatsObj.toTag = session.request.toTag || '';\n    qosStatsObj.localID = session.request.getHeader('From');\n    qosStatsObj.remoteID = session.request.getHeader('To');\n    qosStatsObj.origID = session.request.getHeader('From');\n    const refreshIntervalId = setInterval(async () => {\n        const sessionDescriptionHandler = session.sessionDescriptionHandler;\n        if (!sessionDescriptionHandler?.peerConnection) {\n            session.logger.error('There is no PeerConnection, can not getStats');\n            return;\n        }\n        const getStatsResult = await sessionDescriptionHandler.peerConnection.getStats();\n        session.logger.log(`getStatsResult ${JSON.stringify(getStatsResult)}`);\n        qosStatsObj.status = true;\n        let network = '';\n        getStatsResult.forEach((item) => {\n            switch (item.type) {\n                case 'local-candidate':\n                    if (item.candidateType === 'srflx') {\n                        network = typeof item.networkType === 'string' ? item.networkType : getNetworkType(item.networkType);\n                        qosStatsObj.localAddr = item.ip + ':' + item.port;\n                        qosStatsObj.localcandidate = item;\n                    }\n                    break;\n                case 'remote-candidate':\n                    if (item.candidateType === 'host') {\n                        qosStatsObj.remoteAddr = item.ip + ':' + item.port;\n                        qosStatsObj.remotecandidate = item;\n                    }\n                    break;\n                case 'inbound-rtp': {\n                    qosStatsObj.jitterBufferDiscardRate = item.packetsDiscarded / item.packetsReceived;\n                    qosStatsObj.inboundPacketsLost = item.packetsLost;\n                    qosStatsObj.inboundPacketsReceived = item.packetsReceived; // packetsReceived\n                    const jitterBufferMs = parseFloat(item.jitterBufferEmittedCount) > 0\n                        ? (parseFloat(item.jitterBufferDelay) / parseFloat(item.jitterBufferEmittedCount)) * 1000\n                        : 0;\n                    qosStatsObj.totalSumJitter += jitterBufferMs;\n                    qosStatsObj.totalIntervalCount += 1;\n                    qosStatsObj.NLR = formatFloat((item.packetsLost / (item.packetsLost + item.packetsReceived)) * 100);\n                    qosStatsObj.JBM = Math.max(qosStatsObj.JBM, jitterBufferMs);\n                    qosStatsObj.netType = addToMap(qosStatsObj.netType, network);\n                    break;\n                }\n                case 'candidate-pair':\n                    qosStatsObj.RTD = Math.round((item.currentRoundTripTime / 2) * 1000);\n                    break;\n                case 'outbound-rtp':\n                    qosStatsObj.outboundPacketsSent = item.packetsSent;\n                    break;\n                case 'remote-inbound-rtp':\n                    qosStatsObj.outboundPacketsLost = item.packetsLost;\n                    break;\n                default:\n                    break;\n            }\n        });\n    }, session.userAgent.qosCollectInterval);\n    session.stateChange.addListener((newState) => {\n        if (newState === SessionState.Terminated) {\n            session.logger.log('Release media streams');\n            session.mediaStreams?.release();\n            publishQosStats(session, qosStatsObj);\n            refreshIntervalId && clearInterval(refreshIntervalId);\n        }\n    });\n};\nconst publishQosStats = async (session, qosStatsObj, _options = {}) => {\n    const options = _options || {};\n    const targetUrl = options.targetUrl || 'sip:rtcpxr@rtcpxr.ringcentral.com:5060';\n    const event = options.event || 'vq-rtcpxr';\n    options.expires = 60;\n    options.contentType = 'application/vq-rtcpxr';\n    options.extraHeaders = (options.extraHeaders || []).concat(session.userAgent.defaultHeaders);\n    const cpuOS = session.__qosStats.cpuOS;\n    const cpuRC = session.__qosStats.cpuRC;\n    const ram = session.__qosStats.ram;\n    const networkType = session.__qosStats.netType || calculateNetworkUsage(qosStatsObj) || '';\n    let effectiveType = '';\n    if ('connection' in navigator) {\n        effectiveType = navigator.connection.effectiveType;\n    }\n    options.extraHeaders.push(`p-rc-client-info:cpuRC=${cpuRC};cpuOS=${cpuOS};netType=${networkType};ram=${ram};effectiveType=${effectiveType}`);\n    session.logger.log(`QOS stats ${JSON.stringify(qosStatsObj)}`);\n    const calculatedStatsObj = calculateStats(qosStatsObj);\n    const body = createPublishBody(calculatedStatsObj);\n    const publisher = new Publisher(session.userAgent, UserAgent.makeURI(targetUrl), event, options);\n    await publisher.publish(body);\n    session.logger.log('Local Candidate: ' + JSON.stringify(qosStatsObj.localcandidate));\n    session.logger.log('Remote Candidate: ' + JSON.stringify(qosStatsObj.remotecandidate));\n    qosStatsObj.status = false;\n    await publisher.dispose();\n    session.emit(Events.Session.QOSPublished, body);\n};\nconst calculateNetworkUsage = (qosStatsObj) => {\n    const networkType = [];\n    for (const [key, value] of Object.entries(qosStatsObj.netType)) {\n        networkType.push(key + ':' + formatFloat((value * 100) / qosStatsObj.totalIntervalCount));\n    }\n    return networkType.join();\n};\nconst calculateStats = (qosStatsObj) => {\n    const rawNLR = (qosStatsObj.inboundPacketsLost * 100) / (qosStatsObj.inboundPacketsReceived + qosStatsObj.inboundPacketsLost) || 0;\n    const rawJBN = qosStatsObj.totalIntervalCount > 0 ? qosStatsObj.totalSumJitter / qosStatsObj.totalIntervalCount : 0;\n    return {\n        ...qosStatsObj,\n        NLR: formatFloat(rawNLR),\n        JBN: formatFloat(rawJBN),\n        JDR: formatFloat(qosStatsObj.jitterBufferDiscardRate),\n        MOSLQ: calculateMos(qosStatsObj.inboundPacketsLost / (qosStatsObj.inboundPacketsLost + qosStatsObj.inboundPacketsReceived)),\n        MOSCQ: calculateMos(qosStatsObj.outboundPacketsLost / (qosStatsObj.outboundPacketsLost + qosStatsObj.outboundPacketsSent)),\n    };\n};\nconst createPublishBody = (calculatedStatsObj) => {\n    const NLR = calculatedStatsObj.NLR || 0;\n    const JBM = calculatedStatsObj.JBM || 0;\n    const JBN = calculatedStatsObj.JBN || 0;\n    const JDR = calculatedStatsObj.JDR || 0;\n    const MOSLQ = calculatedStatsObj.MOSLQ || 0;\n    const MOSCQ = calculatedStatsObj.MOSCQ || 0;\n    const RTD = calculatedStatsObj.RTD || 0;\n    const callID = calculatedStatsObj.callID || '';\n    const fromTag = calculatedStatsObj.fromTag || '';\n    const toTag = calculatedStatsObj.toTag || '';\n    const localId = calculatedStatsObj.localID || '';\n    const remoteId = calculatedStatsObj.remoteID || '';\n    const localAddr = calculatedStatsObj.localAddr || '';\n    const remoteAddr = calculatedStatsObj.remoteAddr || '';\n    return ('VQSessionReport: CallTerm\\r\\n' +\n        `CallID: ${callID}\\r\\n` +\n        `LocalID: ${localId}\\r\\n` +\n        `RemoteID: ${remoteId}\\r\\n` +\n        `OrigID: ${localId}\\r\\n` +\n        `LocalAddr: IP=${localAddr} SSRC=0x00000000\\r\\n` +\n        `RemoteAddr: IP=${remoteAddr} SSRC=0x00000000\\r\\n` +\n        'LocalMetrics:\\r\\n' +\n        'Timestamps: START=0 STOP=0\\r\\n' +\n        'SessionDesc: PT=0 PD=opus SR=0 FD=0 FPP=0 PPS=0 PLC=0 SSUP=on\\r\\n' +\n        `JitterBuffer: JBA=0 JBR=0 JBN=${JBN} JBM=${formatFloat(JBM)} JBX=0\\r\\n` +\n        `PacketLoss: NLR=${NLR} JDR=${JDR}\\r\\n` +\n        'BurstGapLoss: BLD=0 BD=0 GLD=0 GD=0 GMIN=0\\r\\n' +\n        `Delay: RTD=${RTD} ESD=0 SOWD=0 IAJ=0\\r\\n` +\n        `QualityEst: MOSLQ=${formatFloat(MOSLQ)} MOSCQ=${formatFloat(MOSCQ)}\\r\\n` +\n        `DialogID: ${callID};to-tag=${toTag};from-tag=${fromTag}`);\n};\nconst getQoSStatsTemplate = () => ({\n    localAddr: '',\n    remoteAddr: '',\n    callID: '',\n    localID: '',\n    remoteID: '',\n    origID: '',\n    fromTag: '',\n    toTag: '',\n    timestamp: {\n        start: '',\n        stop: '',\n    },\n    netType: {},\n    jitterBufferNominal: 0,\n    jitterBufferMax: 0,\n    jitterBufferDiscardRate: 0,\n    totalSumJitter: 0,\n    totalIntervalCount: 0,\n    NLR: '',\n    JBM: 0,\n    JBN: '',\n    JDR: '',\n    MOSLQ: 0,\n    MOSCQ: 0,\n    RTD: 0,\n    status: false,\n    localcandidate: {},\n    remotecandidate: {},\n    inboundPacketsLost: 0,\n    inboundPacketsReceived: 0,\n    outboundPacketsLost: 0,\n    outboundPacketsSent: 0,\n});\nconst addToMap = (map = {}, key) => ({\n    ...map,\n    [key]: (key in map ? parseInt(map[key], 10) : 0) + 1,\n});\nconst networkTypeMap = {\n    bluetooth: 'Bluetooth',\n    cellular: 'Cellulars',\n    ethernet: 'Ethernet',\n    wifi: 'WiFi',\n    vpn: 'VPN',\n    wimax: 'WiMax',\n    '2g': '2G',\n    '3g': '3G',\n    '4g': '4G',\n};\n// TODO: find reliable way to find network type , use navigator.connection.type?\nconst getNetworkType = (connectionType) => {\n    const sysNetwork = connectionType.systemNetworkType || 'unknown';\n    const localNetwork = connectionType || 'unknown';\n    const networkType = !sysNetwork || sysNetwork === 'unknown' ? localNetwork : sysNetwork;\n    return networkType in networkTypeMap ? networkTypeMap[networkType] : networkType;\n};\nfunction calculateMos(packetLoss) {\n    if (packetLoss <= 0.008) {\n        return 4.5;\n    }\n    if (packetLoss > 0.45) {\n        return 1.0;\n    }\n    const bpl = 17.2647;\n    const r = 93.2062077233 - 95.0 * ((packetLoss * 100) / (packetLoss * 100 + bpl)) + 4;\n    let mos = 2.06405 + 0.031738 * r - 0.000356641 * r * r + 2.93143 * Math.pow(10, -6) * r * r * r;\n    if (mos < 1) {\n        return 1.0;\n    }\n    if (mos > 4.5) {\n        return 4.5;\n    }\n    if (packetLoss >= 0.35 && mos > 2.7) {\n        mos = 2.7;\n    }\n    else if (packetLoss >= 0.3 && mos > 3.0) {\n        mos = 3.0;\n    }\n    else if (packetLoss >= 0.2 && mos > 3.6) {\n        mos = 3.6;\n    }\n    else if (packetLoss >= 0.15 && mos > 3.7) {\n        mos = 3.7;\n    }\n    else if (packetLoss >= 0.1 && mos > 3.9) {\n        mos = 4.1;\n    }\n    else if (packetLoss >= 0.05 && mos > 4.1) {\n        mos = 4.3;\n    }\n    else if (packetLoss >= 0.03 && mos > 4.1) {\n        mos = 4.4;\n    }\n    return mos;\n}\n","export function isNoAudio(report) {\n    if (!report.inboundRtpReport) {\n        return true;\n    }\n    if (!report.outboundRtpReport) {\n        return true;\n    }\n    if (report.inboundRtpReport.packetsReceived === 0 || report.outboundRtpReport.packetsSent === 0) {\n        return true;\n    }\n    return false;\n}\n","import { EventEmitter } from 'events';\nimport { RequestPendingError, UserAgent, } from 'sip.js';\nimport { fromBodyLegacy, } from 'sip.js/lib/core';\nimport { SessionState } from 'sip.js/lib/api/session-state';\nimport { extend } from './utils';\nimport { responseTimeout, messages } from './constants';\nimport { MediaStreams } from './mediaStreams';\nimport { isNoAudio } from './rtpReport';\nimport { Events } from './events';\nimport { startQosStatsCollection } from './qos';\nexport class CommonSession {\n    /** @ignore */\n    __isRecording;\n    /** @ignore */\n    __localHold;\n    /** @ignore */\n    __patched;\n    /** @ignore */\n    __userAgentCoreEventsSetup;\n    /** Flag to check if the call is on hold or not */\n    held;\n    /** Options to represent dom elements where media stream should be loaded */\n    media;\n    /** Flag to indicate if media stats are being collected */\n    mediaStatsStarted;\n    /** MediaStreams class instance which has the logic to collect media stream stats */\n    mediaStreams;\n    /** Flag to check if the call is muted or not */\n    muted;\n    /** Counter to represent how many media stats report were missed because of no audio */\n    noAudioReportCount;\n    /** JOSN representation of RC headers received for an incoming call */\n    rcHeaders;\n    __qosStats;\n    /** Flag to represent if reinvite request was sent because there was no audio reported */\n    reinviteForNoAudioSent;\n    /** Time when session was started */\n    startTime;\n    /** @ignore */\n    __accept;\n    /** @ignore */\n    __dispose;\n    /** Method to attach event listener for session specific events */\n    addListener;\n    /** Add track to media source */\n    addTrack;\n    /** RingCentral barge implementation */\n    barge;\n    /** RingCentral blind transfer implementation */\n    blindTransfer;\n    /**\n     * @internal\n     * Helper function which represents if call control features can be used or not\n     */\n    canUseRCMCallControl;\n    /**\n     * @internal\n     * Create session message which would be sent to the RingCentral backend\n     */\n    createSessionMessage;\n    /** Sends a DTMF over the call */\n    dtmf;\n    /** Emit session specific events which will trigger all the event listeners attached */\n    emit;\n    /** RingCentral flip implementation */\n    flip;\n    /** RingCentral flip implementation */\n    forward;\n    /** Put the call on hold */\n    hold;\n    /** Ignore incoming call */\n    ignore;\n    /** Mute the call */\n    mute;\n    /** Remove event listener */\n    off;\n    /** Add event listener. Same as addListener */\n    on;\n    /** Add once event listener. Same as addListener */\n    once;\n    /** Returns if the call is on hold locally or not */\n    onLocalHold;\n    /** RingCentral park implementation */\n    park;\n    /** Send a session reinvite */\n    reinvite;\n    /** Remove event listener */\n    removeListener;\n    /** Remove all event listeners */\n    removeAllListeners;\n    /** RingCentral reply with message implementation */\n    replyWithMessage;\n    /**\n     * @internal\n     * Helper method that sends an INFO request to other user agent and then waits for an INFO request from the other user agent\n     */\n    sendInfoAndReceiveResponse;\n    /**\n     * @internal\n     * Helper function to send INFO request with `move` instruction to RingCentral backend\n     */\n    sendMoveResponse;\n    /** Send `receiveConfirm` command to backend */\n    sendReceiveConfirm;\n    /** Helper function to send session message to backend using UserAgent */\n    sendSessionMessage;\n    /** Start recording the call */\n    startRecord;\n    /** Function to stop collecting media stats */\n    stopMediaStats;\n    /** Stop recording the call */\n    stopRecord;\n    /** Send incoming call to voicemail */\n    toVoicemail;\n    /** Transfer current call */\n    transfer;\n    /** Put the call on unhold */\n    unhold;\n    /** Unmute the call */\n    unmute;\n    /** RingCentral warm transfer implementation */\n    warmTransfer;\n    /** RingCentral whisper implementation */\n    whisper;\n    setQosStats;\n}\nconst mediaCheckTimer = 2000;\nexport function patchWebphoneSession(session) {\n    if (session.__patched) {\n        return session;\n    }\n    session.__patched = true;\n    session.held = false;\n    session.muted = false;\n    session.media = session.userAgent.media;\n    session.__dispose = session.dispose.bind(session);\n    session.dispose = dispose.bind(session);\n    const eventEmitter = new EventEmitter();\n    session.on = eventEmitter.on.bind(eventEmitter);\n    session.off = eventEmitter.off.bind(eventEmitter);\n    session.once = eventEmitter.once.bind(eventEmitter);\n    session.addListener = eventEmitter.addListener.bind(eventEmitter);\n    session.removeListener = eventEmitter.removeListener.bind(eventEmitter);\n    session.removeAllListeners = eventEmitter.removeAllListeners.bind(eventEmitter);\n    session.emit = eventEmitter.emit.bind(eventEmitter);\n    session.sendInfoAndReceiveResponse = sendInfoAndReceiveResponse.bind(session);\n    session.startRecord = startRecord.bind(session);\n    session.stopRecord = stopRecord.bind(session);\n    session.sendMoveResponse = sendMoveResponse.bind(session);\n    session.park = park.bind(session);\n    session.flip = flip.bind(session);\n    session.whisper = whisper.bind(session);\n    session.barge = barge.bind(session);\n    session.mute = mute.bind(session);\n    session.unmute = unmute.bind(session);\n    session.addTrack = addTrack.bind(session);\n    session.stopMediaStats = stopMediaStats.bind(session);\n    session.warmTransfer = warmTransfer.bind(session);\n    session.blindTransfer = blindTransfer.bind(session);\n    session.transfer = transfer.bind(session);\n    session.hold = hold.bind(session);\n    session.unhold = unhold.bind(session);\n    session.dtmf = dtmf.bind(session);\n    session.reinvite = reinvite.bind(session);\n    session.forward = forward.bind(session); // FIXME: Not needed?\n    session.__qosStats = {};\n    session.setQosStats = setQosStats.bind(session);\n    setupUserAgentCoreEvent(session);\n    session.stateChange.addListener((newState) => {\n        switch (newState) {\n            case SessionState.Establishing: {\n                session.emit(Events.Session.Establishing);\n                break;\n            }\n            case SessionState.Established: {\n                stopPlaying(session);\n                session.addTrack();\n                session.emit(Events.Session.Established);\n                break;\n            }\n            case SessionState.Terminating: {\n                stopPlaying(session);\n                stopMediaStreamStats(session);\n                session.emit(Events.Session.Terminating);\n                break;\n            }\n            case SessionState.Terminated: {\n                stopPlaying(session);\n                session.emit(Events.Session.Terminated);\n                break;\n            }\n        }\n    });\n    // FIXME: Do we need this? The replaced session is part of existing sessions and would have already been patched\n    // NEEDED - inviter.ts L191\n    // session.on(\"replaced\", patchWebphoneSession);\n    if (session.userAgent.onSession) {\n        session.userAgent.onSession(session);\n    }\n    session.mediaStatsStarted = false;\n    session.noAudioReportCount = 0;\n    session.reinviteForNoAudioSent = false;\n    return session;\n}\nexport function patchIncomingWebphoneSession(session) {\n    try {\n        parseRcHeader(session);\n    }\n    catch (e) {\n        session.logger.error(\"Can't parse RC headers from invite request due to \" + e);\n    }\n    session.canUseRCMCallControl = canUseRCMCallControl.bind(session);\n    session.createSessionMessage = createSessionMessage.bind(session);\n    session.ignore = ignore.bind(session);\n    session.replyWithMessage = replyWithMessage.bind(session);\n    session.sendReceiveConfirm = sendReceiveConfirm.bind(session);\n    session.sendSessionMessage = sendSessionMessage.bind(session);\n    session.toVoicemail = toVoicemail.bind(session);\n    session.__accept = session.accept.bind(session);\n    session.accept = accept.bind(session);\n    setupUserAgentCoreEvent(session);\n}\nfunction canUseRCMCallControl() {\n    return !!this.rcHeaders;\n}\nfunction createSessionMessage(options) {\n    if (!this.rcHeaders) {\n        throw Error('createSessionMessage options is undefined');\n    }\n    extend(options, {\n        sid: this.rcHeaders.sid,\n        request: this.rcHeaders.request,\n        from: this.rcHeaders.to,\n        to: this.rcHeaders.from,\n    });\n    return this.userAgent.createRcMessage(options);\n}\nasync function sendReceiveConfirm() {\n    return this.sendSessionMessage(messages.receiveConfirm)\n        .then((response) => {\n        this.logger.log('sendReceiveConfirm success');\n        return response;\n    })\n        .catch((error) => this.logger.error(`failed to send receive confirmation via SIP MESSAGE due to ${error.message}`));\n}\nfunction sendSessionMessage(options) {\n    if (!this.rcHeaders) {\n        this.logger.error(\"Can't send SIP MESSAGE related to session: no RC headers available\");\n    }\n    return this.userAgent.sendMessage(this.rcHeaders.from, this.createSessionMessage(options));\n}\nasync function sendInfoAndReceiveResponse(command, _options) {\n    const options = _options || {};\n    extend(command, options);\n    delete command.extraHeaders;\n    return new Promise((resolve, reject) => {\n        const requestDelegate = {\n            onAccept: (response) => {\n                let timeout;\n                const { message: { statusCode, callId }, } = response;\n                if (statusCode === 200) {\n                    const onInfo = (message) => {\n                        // FIXME: I think we need this check here\n                        if (message.callId !== callId) {\n                            return;\n                        }\n                        const body = message?.body || '{}';\n                        let obj;\n                        try {\n                            obj = JSON.parse(body);\n                        }\n                        catch (e) {\n                            obj = {};\n                        }\n                        if (obj.response && obj.response.command === command.command && obj.response.result) {\n                            timeout && clearTimeout(timeout);\n                            this.off('RC_SIP_INFO', onInfo);\n                            if (obj.response.result.code.toString() === '0') {\n                                return resolve(obj.response.result);\n                            }\n                            return reject(obj.response.result);\n                        }\n                    };\n                    timeout = setTimeout(() => {\n                        reject(new Error('Timeout: no reply'));\n                        this.off('RC_SIP_INFO', onInfo);\n                    }, responseTimeout);\n                    this.on('RC_SIP_INFO', onInfo);\n                }\n                else {\n                    reject(new Error(`The INFO response status code is: ${statusCode} (waiting for 200)`));\n                }\n            },\n            onReject: (response) => {\n                reject(new Error(`The INFO response status code is: ${response.message.statusCode} (waiting for 200)`));\n            },\n        };\n        const requestOptions = {\n            extraHeaders: [...(options.extraHeaders || []), ...this.userAgent.defaultHeaders],\n            body: fromBodyLegacy({\n                body: JSON.stringify({ request: command }),\n                contentType: 'application/json;charset=utf-8',\n            }),\n        };\n        this.info({ requestDelegate, requestOptions });\n    });\n}\nasync function startRecord() {\n    return setRecord(this, true);\n}\nasync function stopRecord() {\n    return setRecord(this, false);\n}\n// eslint-disable-next-line max-params\nfunction sendMoveResponse(reqId, code, description, options = {}) {\n    const extraHeaders = options.extraHeaders || [];\n    const requestOptions = {\n        extraHeaders: [...extraHeaders, ...this.userAgent.defaultHeaders],\n        body: fromBodyLegacy({\n            body: JSON.stringify({\n                response: {\n                    reqId,\n                    command: 'move',\n                    result: {\n                        code,\n                        description,\n                    },\n                },\n            }),\n            contentType: 'application/json;charset=utf-8',\n        }),\n    };\n    this.info({ requestOptions });\n}\nfunction ignore() {\n    return this.sendReceiveConfirm().then(() => this.sendSessionMessage(messages.ignore));\n}\nfunction toVoicemail() {\n    return this.sendReceiveConfirm().then(() => this.sendSessionMessage(messages.toVoicemail));\n}\nfunction replyWithMessage(replyOptions) {\n    let body = 'RepTp=\"' + replyOptions.replyType + '\"';\n    if (replyOptions.replyType === 0) {\n        body += ' Bdy=\"' + replyOptions.replyText + '\"';\n    }\n    else if (replyOptions.replyType === 1 || replyOptions.replyType === 4) {\n        body += ' Vl=\"' + replyOptions.timeValue + '\"';\n        body += ' Units=\"' + replyOptions.timeUnits + '\"';\n        body += ' Dir=\"' + replyOptions.callbackDirection + '\"';\n    }\n    return this.sendReceiveConfirm().then(() => this.sendSessionMessage({ reqid: messages.replyWithMessage.reqid, body }));\n}\nasync function flip(target) {\n    return this.sendInfoAndReceiveResponse(messages.flip, { target });\n}\nasync function whisper() {\n    return this.sendInfoAndReceiveResponse(messages.whisper);\n}\nasync function barge() {\n    return this.sendInfoAndReceiveResponse(messages.barge);\n}\nfunction park() {\n    return this.sendInfoAndReceiveResponse(messages.park);\n}\nfunction mute(silent) {\n    if (this.state !== SessionState.Established) {\n        this.logger.warn('An active session is required to mute audio');\n        return;\n    }\n    if (this.muted) {\n        this.logger.debug('Session already muted');\n        return;\n    }\n    this.logger.log('Muting Audio');\n    enableSenderTracks(this, false);\n    this.muted = true;\n    if (!silent) {\n        this.emit(Events.Session.Muted, this);\n    }\n}\nfunction unmute(silent) {\n    if (this.state !== SessionState.Established) {\n        this.logger.warn('An active session is required to unmute audio');\n        return;\n    }\n    if (!this.muted) {\n        this.logger.debug('Session not muted');\n        return;\n    }\n    this.logger.log('Unmuting Audio');\n    enableSenderTracks(this, true);\n    this.muted = false;\n    if (!silent) {\n        this.emit(Events.Session.Unmuted, this);\n    }\n}\nfunction addTrack(remoteAudioEle, localAudioEle) {\n    const sessionDescriptionHandler = this.sessionDescriptionHandler;\n    const peerConnection = sessionDescriptionHandler.peerConnection;\n    let remoteAudio;\n    let localAudio;\n    if (remoteAudioEle && localAudioEle) {\n        remoteAudio = remoteAudioEle;\n        localAudio = localAudioEle;\n    }\n    else if (this.media) {\n        remoteAudio = this.media.remote;\n        localAudio = this.media.local;\n    }\n    else {\n        throw new Error('HTML Media Element not Defined');\n    }\n    // TODO: peerConnecton.remoteMediaStream already has reciver track added thanks to default session description handler. Can we remove this code?\n    let remoteStream = new MediaStream();\n    if (peerConnection?.getReceivers) {\n        peerConnection.getReceivers().forEach((receiver) => {\n            const rtrack = receiver.track;\n            if (rtrack) {\n                remoteStream.addTrack(rtrack);\n                this.logger.log('Remote track added');\n            }\n        });\n    }\n    else {\n        remoteStream = sessionDescriptionHandler.remoteMediaStream;\n        this.logger.log('Remote track added');\n    }\n    remoteAudio.srcObject = remoteStream;\n    remoteAudio.play().catch(() => {\n        this.logger.error('Remote play was rejected');\n    });\n    // TODO: peerConnecton.localMediaStream already has sender track added thanks to default session description handler. Can we remove this code?\n    let localStream = new MediaStream();\n    if (peerConnection?.getSenders) {\n        peerConnection.getSenders().forEach((sender) => {\n            const strack = sender.track;\n            if (strack && strack.kind === 'audio') {\n                localStream.addTrack(strack);\n                this.logger.log('Local track added');\n            }\n        });\n    }\n    else {\n        localStream = sessionDescriptionHandler.localMediaStream;\n        this.logger.log('Local track added');\n    }\n    localAudio.srcObject = localStream;\n    localAudio.play().catch(() => {\n        this.logger.error('Local play was rejected');\n    });\n    if (localStream && remoteStream && !this.mediaStatsStarted) {\n        this.mediaStreams = new MediaStreams(this);\n        this.logger.log('Start gathering media report');\n        this.mediaStatsStarted = true;\n        this.mediaStreams.getMediaStats((report) => {\n            if (this.userAgent.enableMediaReportLogging) {\n                this.logger.log(`Got media report: ${JSON.stringify(report)}`);\n            }\n            if (!this.reinviteForNoAudioSent && isNoAudio(report)) {\n                this.logger.log('No audio report');\n                this.noAudioReportCount++;\n                if (this.noAudioReportCount === 3) {\n                    this.logger.log('No audio for 6 sec. Trying to recover audio by sending Re-invite');\n                    this.mediaStreams.reconnectMedia();\n                    this.reinviteForNoAudioSent = true;\n                    this.noAudioReportCount = 0;\n                }\n            }\n            else if (!isNoAudio(report)) {\n                this.noAudioReportCount = 0;\n            }\n        }, mediaCheckTimer);\n    }\n}\nfunction stopMediaStats() {\n    this.logger.log('Stopping media stats collection');\n    if (!this) {\n        return;\n    }\n    this.mediaStreams?.stopMediaStats();\n    this.mediaStatsStarted = false;\n    this.noAudioReportCount = 0;\n}\nasync function blindTransfer(target, options = {}) {\n    this.logger.log('Call transfer initiated');\n    const newTarget = typeof target === 'string' ? UserAgent.makeURI(`sip:${target}@${this.userAgent.sipInfo.domain}`) : target;\n    return this.refer(newTarget, options);\n}\nasync function warmTransfer(target, options = { requestOptions: { extraHeaders: [] } }) {\n    options.requestOptions.extraHeaders = (options.requestOptions.extraHeaders || []).concat(this.userAgent.defaultHeaders);\n    const newTarget = typeof target === 'string' ? UserAgent.makeURI(`sip:${target}@${this.userAgent.sipInfo.domain}`) : target;\n    this.logger.log('Completing warm transfer');\n    return this.refer(newTarget, options);\n}\nasync function transfer(target, options = { requestOptions: { extraHeaders: [] } }) {\n    options.requestOptions.extraHeaders = (options.requestOptions.extraHeaders || []).concat(this.userAgent.defaultHeaders);\n    return this.blindTransfer(target, options);\n}\n/**\n *\n * @param this WebPhoneSessionSessionInviteOptions\n * @param options\n * @returns Promise<OutgoingInviteRequest>\n *\n * Sends a reinvite. Also makes sure to regenerate a new SDP by passing offerToReceiveAudio: true, offerToReceiveVideo: false  and iceRestart: true\n * Once the SDP is ready, the local description is set and the SDP is sent to the remote peer along with an INVITE request\n */\nfunction reinvite(options = {}) {\n    options.sessionDescriptionHandlerOptions = {\n        ...options.sessionDescriptionHandlerOptions,\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: false,\n        iceRestart: true,\n    };\n    options.requestDelegate = options.requestDelegate || {};\n    const originalOnAccept = options.requestDelegate.onAccept?.bind(options.requestDelegate);\n    options.requestDelegate.onAccept = (...args) => {\n        patchIncomingWebphoneSession(this);\n        originalOnAccept?.(...args);\n    };\n    return this.invite(options);\n}\nasync function hold() {\n    this.stopMediaStats();\n    try {\n        this.logger.log('Hold Initiated');\n        await setHold(this, true);\n        this.logger.log('Hold completed, held is set to true');\n    }\n    catch (e) {\n        throw new Error('Hold could not be completed');\n    }\n}\nasync function unhold() {\n    try {\n        this.logger.log('Unhold Initiated');\n        await setHold(this, false);\n        this.logger.log('Unhold completed, held is set to false');\n    }\n    catch (e) {\n        throw new Error('Unhold could not be completed');\n    }\n}\n// eslint-disable-next-line max-params\nfunction dtmf(dtmf, _duration = 100, _interToneGap = 50) {\n    const duration = parseInt(_duration.toString(), 10);\n    const interToneGap = parseInt(_interToneGap.toString(), 10);\n    const sessionDescriptionHandler = this.sessionDescriptionHandler;\n    const peerConnection = sessionDescriptionHandler.peerConnection;\n    if (!peerConnection) {\n        this.logger.error('Peer connection closed.');\n        return;\n    }\n    const senders = peerConnection.getSenders();\n    const audioSender = senders.find((sender) => sender.track && sender.track.kind === 'audio');\n    const dtmfSender = audioSender.dtmf;\n    if (dtmfSender !== undefined && dtmfSender) {\n        this.logger.log(`Send DTMF: ${dtmf} Duration: ${duration} InterToneGap: ${interToneGap}`);\n        return dtmfSender.insertDTMF(dtmf, duration, interToneGap);\n    }\n    throw new Error('Send DTMF failed');\n}\nasync function accept(_options = {}) {\n    const options = _options || {};\n    options.extraHeaders = (options.extraHeaders || []).concat(this.userAgent.defaultHeaders);\n    options.sessionDescriptionHandlerOptions = {\n        ...options.sessionDescriptionHandlerOptions,\n    };\n    options.sessionDescriptionHandlerOptions.constraints = options.sessionDescriptionHandlerOptions.constraints || {\n        ...this.userAgent.constraints,\n        optional: [{ DtlsSrtpKeyAgreement: 'true' }],\n    };\n    try {\n        await this.__accept(options);\n        this.startTime = new Date();\n        this.emit(Events.Session.Accepted, this.request);\n    }\n    catch (e) {\n        if (e.message.indexOf('Permission denied') !== -1) {\n            this.emit(Events.Session.UserMediaFailed);\n        }\n    }\n}\n// eslint-disable-next-line max-params\nasync function forward(target, acceptOptions, transferOptions) {\n    await this.accept(acceptOptions);\n    return new Promise((resolve) => {\n        this.mute();\n        setTimeout(() => {\n            resolve(this.transfer(target, transferOptions));\n        }, 700);\n    });\n}\nasync function dispose() {\n    stopMediaStreamStats(this);\n    this.__dispose();\n}\n/* ---------------------------------------------------------- HELPER FUNCTIONS ---------------------------------------------------------- */\nfunction parseRcHeaderString(str = '') {\n    const pairs = str.split(/; */).filter((pair) => pair.includes('=')); // skip things that don't look like key=value\n    const result = {};\n    for (const pair of pairs) {\n        let [key, value] = pair.split('=');\n        key = key.trim();\n        value = value.trim();\n        if (!(key in result)) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\nfunction parseRcHeader(session) {\n    const prc = session.request.getHeader('P-Rc');\n    const prcCallInfo = session.request.getHeader('P-Rc-Api-Call-Info');\n    if (prc) {\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(prc, 'text/xml');\n        const hdrNode = xmlDoc.getElementsByTagName('Hdr')[0];\n        const bdyNode = xmlDoc.getElementsByTagName('Bdy')[0];\n        if (hdrNode) {\n            session.rcHeaders = {\n                sid: hdrNode.getAttribute('SID') || undefined,\n                request: hdrNode.getAttribute('Req') || undefined,\n                from: hdrNode.getAttribute('From') || undefined,\n                to: hdrNode.getAttribute('To') || undefined,\n            };\n        }\n        if (bdyNode) {\n            extend(session.rcHeaders, {\n                srvLvl: bdyNode.getAttribute('SrvLvl'),\n                srvLvlExt: bdyNode.getAttribute('SrvLvlExt'),\n                nm: bdyNode.getAttribute('Nm'),\n                toNm: bdyNode.getAttribute('ToNm'),\n            });\n        }\n    }\n    if (prcCallInfo) {\n        const parsed = parseRcHeaderString(prcCallInfo);\n        extend(session.rcHeaders, parsed);\n    }\n}\nasync function setRecord(session, flag) {\n    const message = flag ? messages.startRecord : messages.stopRecord;\n    if ((session.__isRecording && !flag) || (!session.__isRecording && flag)) {\n        const data = await session.sendInfoAndReceiveResponse(message);\n        session.__isRecording = !!flag;\n        return data;\n    }\n}\nfunction enableReceiverTracks(session, enable) {\n    const sessionDescriptionHandler = session.sessionDescriptionHandler;\n    const peerConnection = sessionDescriptionHandler.peerConnection;\n    if (!peerConnection) {\n        session.logger.error('Peer connection closed.');\n        return;\n    }\n    peerConnection.getReceivers().forEach((receiver) => {\n        if (receiver.track) {\n            receiver.track.enabled = enable;\n        }\n    });\n}\nfunction enableSenderTracks(session, enable) {\n    const sessionDescriptionHandler = session.sessionDescriptionHandler;\n    const peerConnection = sessionDescriptionHandler.peerConnection;\n    if (!peerConnection) {\n        session.logger.error('Peer connection closed.');\n        return;\n    }\n    peerConnection.getSenders().forEach((sender) => {\n        if (sender.track) {\n            sender.track.enabled = enable;\n        }\n    });\n}\nfunction setHold(session, hold) {\n    return new Promise((resolve, reject) => {\n        // Just resolve if we are already in correct state\n        if (session.held === hold) {\n            resolve();\n            return;\n        }\n        const options = {\n            requestDelegate: {\n                onAccept: async (response) => {\n                    session.held = hold;\n                    const sessionDescriptionHandler = session.sessionDescriptionHandler;\n                    const peerConnection = sessionDescriptionHandler.peerConnection;\n                    const localSdp = peerConnection.localDescription.sdp;\n                    const match = localSdp.match(/a=(sendrecv|sendonly|recvonly|inactive)/);\n                    const direction = match ? match[1] : '';\n                    session.__localHold = response.message.statusCode === 200 && direction === 'sendonly';\n                    session.logger.log('localhold is set to ' + session.__localHold);\n                    enableReceiverTracks(session, !session.held);\n                    enableSenderTracks(session, !session.held && !session.muted);\n                    resolve();\n                },\n                onReject: () => {\n                    session.logger.warn('re-invite request was rejected');\n                    enableReceiverTracks(session, !session.held);\n                    enableSenderTracks(session, !session.held && !session.muted);\n                    reject(new Error('re-invite request was rejected'));\n                },\n            },\n        };\n        // Session properties used to pass options to the SessionDescriptionHandler:\n        //\n        // 1) Session.sessionDescriptionHandlerOptions\n        //    SDH options for the initial INVITE transaction.\n        //    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n        //    - May be set directly at anytime.\n        //    - May optionally be set via constructor option.\n        //    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n        //\n        // 2) Session.sessionDescriptionHandlerOptionsReInvite\n        //    SDH options for re-INVITE transactions.\n        //    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n        //    - May be set directly at anytime.\n        //    - May optionally be set via constructor option.\n        //    - May optionally be set via options passed to Session.invite().\n        const sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite;\n        sessionDescriptionHandlerOptions.hold = hold;\n        session.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n        // Send re-INVITE\n        session\n            .invite(options)\n            .then(() => {\n            // preemptively enable/disable tracks\n            enableReceiverTracks(session, !hold);\n            enableSenderTracks(session, !hold && !session.muted);\n        })\n            .catch((error) => {\n            if (error instanceof RequestPendingError) {\n                session.logger.error('A hold request is already in progress.');\n            }\n            reject(error);\n        });\n    });\n}\nfunction stopPlaying(session) {\n    session.userAgent.audioHelper.playOutgoing(false);\n    session.userAgent.audioHelper.playIncoming(false);\n}\nexport function onSessionDescriptionHandlerCreated(session) {\n    if (!session.userAgent.enableQos) {\n        return;\n    }\n    session.logger.log('SessionDescriptionHandler created');\n    startQosStatsCollection(session);\n    navigator.mediaDevices.enumerateDevices().then((devices) => {\n        devices.forEach((device) => session.logger.log(`${device.kind} = ${device.label} ${JSON.stringify(device)}`));\n    });\n}\nfunction setupUserAgentCoreEvent(session) {\n    if (session.__userAgentCoreEventsSetup) {\n        return;\n    }\n    const userAgentCore = session.userAgent.userAgentCore;\n    userAgentCore.on(Events.Session.UpdateReceived, (payload) => session.emit(Events.Session.UpdateReceived, payload));\n    userAgentCore.on(Events.Session.MoveToRcv, (payload) => session.emit(Events.Session.MoveToRcv, payload));\n    // RC_SIP_INFO event is for internal use\n    userAgentCore.on('RC_SIP_INFO', (payload) => session.emit('RC_SIP_INFO', payload));\n    session.__userAgentCoreEventsSetup = true;\n}\nfunction stopMediaStreamStats(session) {\n    if (session.mediaStreams) {\n        session.logger.log('Releasing media streams');\n        session.mediaStreams.release();\n    }\n}\nfunction onLocalHold() {\n    return this.__localHold;\n}\nfunction setQosStats(stats) {\n    this.__qosStats.cpuOS = stats.cpuOS || '0:0:0';\n    this.__qosStats.cpuRC = stats.cpuRC || '0:0:0';\n    this.__qosStats.ram = stats.ram || '0:0:0';\n    this.__qosStats.netType = stats.netType || undefined;\n}\n","/**\n * A base class implementing a WebRTC session description handler for sip.js.\n * @remarks\n * It is expected/intended to be extended by specific WebRTC based applications.\n * @privateRemarks\n * So do not put application specific implementation in here.\n * @public\n */\nexport class SessionDescriptionHandler {\n    // The addtrack event does not get fired when JavaScript code explicitly adds tracks to the stream (by calling addTrack()).\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n    static dispatchAddTrackEvent(stream, track) {\n        stream.dispatchEvent(new MediaStreamTrackEvent('addtrack', { track }));\n    }\n    // The removetrack event does not get fired when JavaScript code explicitly removes tracks from the stream (by calling removeTrack()).\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onremovetrack\n    static dispatchRemoveTrackEvent(stream, track) {\n        stream.dispatchEvent(new MediaStreamTrackEvent('removetrack', { track }));\n    }\n    /** Logger. */\n    logger;\n    /** Media stream factory. */\n    mediaStreamFactory;\n    /** Configuration options. */\n    sessionDescriptionHandlerConfiguration;\n    /** The local media stream. */\n    _localMediaStream;\n    /** The remote media stream. */\n    _remoteMediaStream;\n    /** The data channel. Undefined before created. */\n    _dataChannel;\n    /** The peer connection. Undefined after SessionDescriptionHandler.close(). */\n    _peerConnection;\n    /** The peer connection delegate. */\n    _peerConnectionDelegate;\n    iceGatheringCompletePromise;\n    iceGatheringCompleteTimeoutId;\n    iceGatheringCompleteResolve;\n    iceGatheringCompleteReject;\n    localMediaStreamConstraints;\n    onDataChannel;\n    /**\n     * Constructor\n     * @param logger - A logger\n     * @param mediaStreamFactory - A factory to provide a MediaStream\n     * @param options - Options passed from the SessionDescriptionHandleFactory\n     */\n    constructor(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration) {\n        logger.debug('SessionDescriptionHandler.constructor');\n        this.logger = logger;\n        this.mediaStreamFactory = mediaStreamFactory;\n        this.sessionDescriptionHandlerConfiguration = sessionDescriptionHandlerConfiguration;\n        this._localMediaStream = new MediaStream();\n        this._remoteMediaStream = new MediaStream();\n        this._peerConnection = new RTCPeerConnection(sessionDescriptionHandlerConfiguration?.peerConnectionConfiguration);\n        this.initPeerConnectionEventHandlers();\n    }\n    /**\n     * The local media stream currently being sent.\n     *\n     * @remarks\n     * The local media stream initially has no tracks, so the presence of tracks\n     * should not be assumed. Furthermore, tracks may be added or removed if the\n     * local media changes - for example, on upgrade from audio only to a video session.\n     * At any given time there will be at most one audio track and one video track\n     * (it's possible that this restriction may not apply to sub-classes).\n     * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n     * to detect when a new track becomes available:\n     * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n     */\n    get localMediaStream() {\n        return this._localMediaStream;\n    }\n    /**\n     * The remote media stream currently being received.\n     *\n     * @remarks\n     * The remote media stream initially has no tracks, so the presence of tracks\n     * should not be assumed. Furthermore, tracks may be added or removed if the\n     * remote media changes - for example, on upgrade from audio only to a video session.\n     * At any given time there will be at most one audio track and one video track\n     * (it's possible that this restriction may not apply to sub-classes).\n     * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n     * to detect when a new track becomes available:\n     * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n     */\n    get remoteMediaStream() {\n        return this._remoteMediaStream;\n    }\n    /**\n     * The data channel. Undefined before it is created.\n     */\n    get dataChannel() {\n        return this._dataChannel;\n    }\n    /**\n     * The peer connection. Undefined if peer connection has closed.\n     *\n     * @remarks\n     * While access to the underlying `RTCPeerConnection` is provided, note that\n     * using methods with modify it may break the operation of this class.\n     * In particular, this class depends on exclusive access to the\n     * event handler properties. If you need access to the peer connection\n     * events, either register for events using `addEventListener()` on\n     * the `RTCPeerConnection` or set the `peerConnectionDelegate` on\n     * this `SessionDescriptionHandler`.\n     */\n    get peerConnection() {\n        return this._peerConnection;\n    }\n    /**\n     * A delegate which provides access to the peer connection event handlers.\n     *\n     * @remarks\n     * Setting the peer connection event handlers directly is not supported\n     * and may break this class. As this class depends on exclusive access\n     * to them, a delegate may be set which provides alternative access to\n     * the event handlers in a fashion which is supported.\n     */\n    get peerConnectionDelegate() {\n        return this._peerConnectionDelegate;\n    }\n    set peerConnectionDelegate(delegate) {\n        this._peerConnectionDelegate = delegate;\n    }\n    /**\n     * Stop tracks and close peer connection.\n     */\n    close() {\n        this.logger.debug('SessionDescriptionHandler.close');\n        if (this._peerConnection === undefined) {\n            return;\n        }\n        this._peerConnection.getReceivers().forEach((receiver) => {\n            receiver.track?.stop();\n        });\n        this._peerConnection.getSenders().forEach((sender) => {\n            sender.track?.stop();\n        });\n        if (this._dataChannel) {\n            this._dataChannel.close();\n        }\n        this._peerConnection.close();\n        this._peerConnection = undefined;\n    }\n    /**\n     * Creates an offer or answer.\n     * @param options - Options bucket.\n     * @param modifiers - Modifiers.\n     */\n    getDescription(options, modifiers) {\n        this.logger.debug('SessionDescriptionHandler.getDescription');\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error('Peer connection closed.'));\n        }\n        // Callback on data channel creation\n        this.onDataChannel = options?.onDataChannel;\n        // ICE will restart upon applying an offer created with the iceRestart option\n        const iceRestart = options?.offerOptions?.iceRestart;\n        // ICE gathering timeout may be set on a per call basis, otherwise the configured default is used\n        const iceTimeout = options?.iceGatheringTimeout === undefined\n            ? this.sessionDescriptionHandlerConfiguration?.iceGatheringTimeout\n            : options?.iceGatheringTimeout;\n        return this.getLocalMediaStream(options)\n            .then(() => this.enableSenderDscp())\n            .then(() => this.updateDirection(options))\n            .then(() => this.createDataChannel(options))\n            .then(() => this.createLocalOfferOrAnswer(options))\n            .then((sessionDescription) => this.applyModifiers(sessionDescription, modifiers))\n            .then((sessionDescription) => this.setLocalSessionDescription(sessionDescription))\n            .then(() => this.waitForIceGatheringComplete(iceRestart, iceTimeout))\n            .then(() => this.getLocalSessionDescription())\n            .then((sessionDescription) => {\n            return {\n                body: sessionDescription.sdp,\n                contentType: 'application/sdp',\n            };\n        })\n            .catch((error) => {\n            this.logger.error('SessionDescriptionHandler.getDescription failed - ' + error);\n            throw error;\n        });\n    }\n    /**\n     * Returns true if the SessionDescriptionHandler can handle the Content-Type described by a SIP message.\n     * @param contentType - The content type that is in the SIP Message.\n     */\n    hasDescription(contentType) {\n        this.logger.debug('SessionDescriptionHandler.hasDescription');\n        return contentType === 'application/sdp';\n    }\n    /**\n     * Send DTMF via RTP (RFC 4733).\n     * Returns true if DTMF send is successful, false otherwise.\n     * @param tones - A string containing DTMF digits.\n     * @param options - Options object to be used by sendDtmf.\n     */\n    sendDtmf(tones, options) {\n        this.logger.debug('SessionDescriptionHandler.sendDtmf');\n        if (this._peerConnection === undefined) {\n            this.logger.error('SessionDescriptionHandler.sendDtmf failed - peer connection closed');\n            return false;\n        }\n        const senders = this._peerConnection.getSenders();\n        if (senders.length === 0) {\n            this.logger.error('SessionDescriptionHandler.sendDtmf failed - no senders');\n            return false;\n        }\n        const dtmfSender = senders[0].dtmf;\n        if (!dtmfSender) {\n            this.logger.error('SessionDescriptionHandler.sendDtmf failed - no DTMF sender');\n            return false;\n        }\n        const duration = options?.duration;\n        const interToneGap = options?.interToneGap;\n        try {\n            dtmfSender.insertDTMF(tones, duration, interToneGap);\n        }\n        catch (e) {\n            this.logger.error(e);\n            return false;\n        }\n        this.logger.log('SessionDescriptionHandler.sendDtmf sent via RTP: ' + tones.toString());\n        return true;\n    }\n    /**\n     * Sets an offer or answer.\n     * @param sdp - The session description.\n     * @param options - Options bucket.\n     * @param modifiers - Modifiers.\n     */\n    setDescription(sdp, options, modifiers) {\n        this.logger.debug('SessionDescriptionHandler.setDescription');\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error('Peer connection closed.'));\n        }\n        // Callback on data channel creation\n        this.onDataChannel = options?.onDataChannel;\n        // SDP type\n        const type = this._peerConnection.signalingState === 'have-local-offer' ? 'answer' : 'offer';\n        return this.getLocalMediaStream(options)\n            .then(() => this.applyModifiers({ sdp, type }, modifiers))\n            .then((sessionDescription) => this.setRemoteSessionDescription(sessionDescription))\n            .catch((error) => {\n            this.logger.error('SessionDescriptionHandler.setDescription failed - ' + error);\n            throw error;\n        });\n    }\n    /**\n     * Applies modifiers to SDP prior to setting the local or remote description.\n     * @param sdp - SDP to modify.\n     * @param modifiers - Modifiers to apply.\n     */\n    applyModifiers(sdp, modifiers) {\n        this.logger.debug('SessionDescriptionHandler.applyModifiers');\n        if (!modifiers || modifiers.length === 0) {\n            return Promise.resolve(sdp);\n        }\n        return modifiers\n            .reduce((cur, next) => cur.then(next), Promise.resolve(sdp))\n            .then((modified) => {\n            this.logger.debug('SessionDescriptionHandler.applyModifiers - modified sdp');\n            if (!modified.sdp || !modified.type) {\n                throw new Error('Invalid SDP.');\n            }\n            return { sdp: modified.sdp, type: modified.type };\n        });\n    }\n    /**\n     * Create a data channel.\n     * @remarks\n     * Only creates a data channel if SessionDescriptionHandlerOptions.dataChannel is true.\n     * Only creates a data channel if creating a local offer.\n     * Only if one does not already exist.\n     * @param options - Session description handler options.\n     */\n    createDataChannel(options) {\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error('Peer connection closed.'));\n        }\n        // only create a data channel if requested\n        if (options?.dataChannel !== true) {\n            return Promise.resolve();\n        }\n        // do not create a data channel if we already have one\n        if (this._dataChannel) {\n            return Promise.resolve();\n        }\n        switch (this._peerConnection.signalingState) {\n            case 'stable':\n                // if we are stable, assume we are creating a local offer so create a data channel\n                this.logger.debug('SessionDescriptionHandler.createDataChannel - creating data channel');\n                try {\n                    this._dataChannel = this._peerConnection.createDataChannel(options?.dataChannelLabel || '', options?.dataChannelOptions);\n                    if (this.onDataChannel) {\n                        this.onDataChannel(this._dataChannel);\n                    }\n                    return Promise.resolve();\n                }\n                catch (error) {\n                    return Promise.reject(error);\n                }\n            case 'have-remote-offer':\n                return Promise.resolve();\n            case 'have-local-offer':\n            case 'have-local-pranswer':\n            case 'have-remote-pranswer':\n            case 'closed':\n            default:\n                return Promise.reject(new Error('Invalid signaling state ' + this._peerConnection.signalingState));\n        }\n    }\n    /**\n     * Depending on current signaling state, create a local offer or answer.\n     * @param options - Session description handler options.\n     */\n    createLocalOfferOrAnswer(options) {\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error('Peer connection closed.'));\n        }\n        switch (this._peerConnection.signalingState) {\n            case 'stable':\n                // if we are stable, assume we are creating a local offer\n                this.logger.debug('SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP offer');\n                return this._peerConnection.createOffer(options?.offerOptions);\n            case 'have-remote-offer':\n                // if we have a remote offer, assume we are creating a local answer\n                this.logger.debug('SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP answer');\n                return this._peerConnection.createAnswer(options?.answerOptions);\n            case 'have-local-offer':\n            case 'have-local-pranswer':\n            case 'have-remote-pranswer':\n            case 'closed':\n            default:\n                return Promise.reject(new Error('Invalid signaling state ' + this._peerConnection.signalingState));\n        }\n    }\n    /**\n     * Get a media stream from the media stream factory and set the local media stream.\n     * @param options - Session description handler options.\n     */\n    getLocalMediaStream(options) {\n        this.logger.debug('SessionDescriptionHandler.getLocalMediaStream');\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error('Peer connection closed.'));\n        }\n        let constraints = { ...options?.constraints };\n        // if we already have a local media stream...\n        if (this.localMediaStreamConstraints) {\n            // ignore constraint \"downgrades\"\n            constraints.audio = constraints.audio || this.localMediaStreamConstraints.audio;\n            constraints.video = constraints.video || this.localMediaStreamConstraints.video;\n            // if constraints have not changed, do not get a new media stream\n            if (JSON.stringify(this.localMediaStreamConstraints.audio) === JSON.stringify(constraints.audio) &&\n                JSON.stringify(this.localMediaStreamConstraints.video) === JSON.stringify(constraints.video)) {\n                return Promise.resolve();\n            }\n        }\n        else {\n            // if no constraints have been specified, default to audio for initial media stream\n            if (constraints.audio === undefined && constraints.video === undefined) {\n                constraints = { audio: true };\n            }\n        }\n        this.localMediaStreamConstraints = constraints;\n        return this.mediaStreamFactory(constraints, this).then((mediaStream) => this.setLocalMediaStream(mediaStream));\n    }\n    /**\n     * Sets the encoding priorty to high for sender track.\n     *\n     */\n    async enableSenderDscp() {\n        if (!this.sessionDescriptionHandlerConfiguration?.enableDscp) {\n            return;\n        }\n        if (!this._peerConnection) {\n            throw new Error('Peer connection undefined.');\n        }\n        for (const sender of this._peerConnection.getSenders().filter((sender) => sender.track)) {\n            const parameters = sender.getParameters();\n            console.info('getsender params =', parameters);\n            parameters.priority = 'high';\n            try {\n                await sender.setParameters(parameters);\n            }\n            catch (error) {\n                console.error(`Error while setting encodings parameters for ${sender.track.kind} Track ${sender.track.id}: ${error.message || error.name}`);\n            }\n        }\n    }\n    /**\n     * Sets the peer connection's sender tracks and local media stream tracks.\n     *\n     * @remarks\n     * Only the first audio and video tracks of the provided MediaStream are utilized.\n     * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n     *\n     * @param stream - Media stream containing tracks to be utilized.\n     */\n    setLocalMediaStream(stream) {\n        this.logger.debug('SessionDescriptionHandler.setLocalMediaStream');\n        if (!this._peerConnection) {\n            throw new Error('Peer connection undefined.');\n        }\n        const pc = this._peerConnection;\n        const localStream = this._localMediaStream;\n        const trackUpdates = [];\n        const updateTrack = (newTrack) => {\n            const kind = newTrack.kind;\n            if (kind !== 'audio' && kind !== 'video') {\n                throw new Error(`Unknown new track kind ${kind}.`);\n            }\n            const sender = pc.getSenders().find((sender) => sender.track && sender.track.kind === kind);\n            if (sender) {\n                trackUpdates.push(new Promise((resolve) => {\n                    this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - replacing sender ${kind} track`);\n                    resolve();\n                }).then(() => sender\n                    .replaceTrack(newTrack)\n                    .then(() => {\n                    const oldTrack = localStream.getTracks().find((localTrack) => localTrack.kind === kind);\n                    if (oldTrack) {\n                        oldTrack.stop();\n                        localStream.removeTrack(oldTrack);\n                        SessionDescriptionHandler.dispatchRemoveTrackEvent(localStream, oldTrack);\n                    }\n                    localStream.addTrack(newTrack);\n                    SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n                })\n                    .catch((error) => {\n                    this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to replace sender ${kind} track`);\n                    throw error;\n                })));\n            }\n            else {\n                trackUpdates.push(new Promise((resolve) => {\n                    this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - adding sender ${kind} track`);\n                    resolve();\n                }).then(() => {\n                    // Review: could make streamless tracks a configurable option?\n                    // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addTrack#Usage_notes\n                    try {\n                        pc.addTrack(newTrack, localStream);\n                    }\n                    catch (error) {\n                        this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to add sender ${kind} track`);\n                        throw error;\n                    }\n                    localStream.addTrack(newTrack);\n                    SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n                }));\n            }\n        };\n        // update peer connection audio tracks\n        const audioTracks = stream.getAudioTracks();\n        if (audioTracks.length) {\n            updateTrack(audioTracks[0]);\n        }\n        // update peer connection video tracks\n        const videoTracks = stream.getVideoTracks();\n        if (videoTracks.length) {\n            updateTrack(videoTracks[0]);\n        }\n        return trackUpdates.reduce((p, x) => p.then(() => x), Promise.resolve());\n    }\n    /**\n     * Gets the peer connection's local session description.\n     */\n    getLocalSessionDescription() {\n        this.logger.debug('SessionDescriptionHandler.getLocalSessionDescription');\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error('Peer connection closed.'));\n        }\n        const sdp = this._peerConnection.localDescription;\n        if (!sdp) {\n            return Promise.reject(new Error('Failed to get local session description'));\n        }\n        return Promise.resolve(sdp);\n    }\n    /**\n     * Sets the peer connection's local session description.\n     * @param sessionDescription - sessionDescription The session description.\n     */\n    setLocalSessionDescription(sessionDescription) {\n        this.logger.debug('SessionDescriptionHandler.setLocalSessionDescription');\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error('Peer connection closed.'));\n        }\n        return this._peerConnection.setLocalDescription(sessionDescription);\n    }\n    /**\n     * Sets the peer connection's remote session description.\n     * @param sessionDescription - The session description.\n     */\n    setRemoteSessionDescription(sessionDescription) {\n        this.logger.debug('SessionDescriptionHandler.setRemoteSessionDescription');\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error('Peer connection closed.'));\n        }\n        const sdp = sessionDescription.sdp;\n        let type;\n        switch (this._peerConnection.signalingState) {\n            case 'stable':\n                // if we are stable assume this is a remote offer\n                type = 'offer';\n                break;\n            case 'have-local-offer':\n                // if we made an offer, assume this is a remote answer\n                type = 'answer';\n                break;\n            case 'have-local-pranswer':\n            case 'have-remote-offer':\n            case 'have-remote-pranswer':\n            case 'closed':\n            default:\n                return Promise.reject(new Error('Invalid signaling state ' + this._peerConnection.signalingState));\n        }\n        if (!sdp) {\n            this.logger.error('SessionDescriptionHandler.setRemoteSessionDescription failed - cannot set null sdp');\n            return Promise.reject(new Error('SDP is undefined'));\n        }\n        return this._peerConnection.setRemoteDescription({ sdp, type });\n    }\n    /**\n     * Sets a remote media stream track.\n     *\n     * @remarks\n     * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n     *\n     * @param track - Media stream track to be utilized.\n     */\n    setRemoteTrack(track) {\n        this.logger.debug('SessionDescriptionHandler.setRemoteTrack');\n        const remoteStream = this._remoteMediaStream;\n        if (remoteStream.getTrackById(track.id)) {\n            this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - have remote ${track.kind} track`);\n        }\n        else if (track.kind === 'audio') {\n            this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);\n            remoteStream.getAudioTracks().forEach((track) => {\n                track.stop();\n                remoteStream.removeTrack(track);\n                SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n            });\n            remoteStream.addTrack(track);\n            SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n        }\n        else if (track.kind === 'video') {\n            this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);\n            remoteStream.getVideoTracks().forEach((track) => {\n                track.stop();\n                remoteStream.removeTrack(track);\n                SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n            });\n            remoteStream.addTrack(track);\n            SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n        }\n    }\n    /**\n     * Depending on the current signaling state and the session hold state, update transceiver direction.\n     * @param options - Session description handler options.\n     */\n    updateDirection(options) {\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error('Peer connection closed.'));\n        }\n        // 4.2.3.  setDirection\n        //\n        //    The setDirection method sets the direction of a transceiver, which\n        //    affects the direction property of the associated \"m=\" section on\n        //    future calls to createOffer and createAnswer.  The permitted values\n        //    for direction are \"recvonly\", \"sendrecv\", \"sendonly\", and \"inactive\",\n        //    mirroring the identically named direction attributes defined in\n        //    [RFC4566], Section 6.\n        //\n        //    When creating offers, the transceiver direction is directly reflected\n        //    in the output, even for re-offers.  When creating answers, the\n        //    transceiver direction is intersected with the offered direction, as\n        //    explained in Section 5.3 below.\n        //\n        //    Note that while setDirection sets the direction property of the\n        //    transceiver immediately (Section 4.2.4), this property does not\n        //    immediately affect whether the transceiver's RtpSender will send or\n        //    its RtpReceiver will receive.  The direction in effect is represented\n        //    by the currentDirection property, which is only updated when an\n        //    answer is applied.\n        //\n        // 4.2.4.  direction\n        //\n        //    The direction property indicates the last value passed into\n        //    setDirection.  If setDirection has never been called, it is set to\n        //    the direction the transceiver was initialized with.\n        //\n        // 4.2.5.  currentDirection\n        //\n        //    The currentDirection property indicates the last negotiated direction\n        //    for the transceiver's associated \"m=\" section.  More specifically, it\n        //    indicates the direction attribute [RFC3264] of the associated \"m=\"\n        //    section in the last applied answer (including provisional answers),\n        //    with \"send\" and \"recv\" directions reversed if it was a remote answer.\n        //    For example, if the direction attribute for the associated \"m=\"\n        //    section in a remote answer is \"recvonly\", currentDirection is set to\n        //    \"sendonly\".\n        //\n        //    If an answer that references this transceiver has not yet been\n        //    applied or if the transceiver is stopped, currentDirection is set to\n        //    \"null\".\n        //  https://tools.ietf.org/html/rfc8829#section-4.2.3\n        //\n        // *  A direction attribute, determined by applying the rules regarding\n        //    the offered direction specified in [RFC3264], Section 6.1, and\n        //    then intersecting with the direction of the associated\n        //    RtpTransceiver.  For example, in the case where an \"m=\" section is\n        //    offered as \"sendonly\" and the local transceiver is set to\n        //    \"sendrecv\", the result in the answer is a \"recvonly\" direction.\n        // https://tools.ietf.org/html/rfc8829#section-5.3.1\n        //\n        // If a stream is offered as sendonly, the corresponding stream MUST be\n        // marked as recvonly or inactive in the answer.  If a media stream is\n        // listed as recvonly in the offer, the answer MUST be marked as\n        // sendonly or inactive in the answer.  If an offered media stream is\n        // listed as sendrecv (or if there is no direction attribute at the\n        // media or session level, in which case the stream is sendrecv by\n        // default), the corresponding stream in the answer MAY be marked as\n        // sendonly, recvonly, sendrecv, or inactive.  If an offered media\n        // stream is listed as inactive, it MUST be marked as inactive in the\n        // answer.\n        // https://tools.ietf.org/html/rfc3264#section-6.1\n        switch (this._peerConnection.signalingState) {\n            case 'stable':\n                // if we are stable, assume we are creating a local offer\n                this.logger.debug('SessionDescriptionHandler.updateDirection - setting offer direction');\n                {\n                    // determine the direction to offer given the current direction and hold state\n                    const directionToOffer = (currentDirection) => {\n                        switch (currentDirection) {\n                            case 'inactive':\n                                return options?.hold ? 'inactive' : 'recvonly';\n                            case 'recvonly':\n                                return options?.hold ? 'inactive' : 'recvonly';\n                            case 'sendonly':\n                                return options?.hold ? 'sendonly' : 'sendrecv';\n                            case 'sendrecv':\n                                return options?.hold ? 'sendonly' : 'sendrecv';\n                            case 'stopped':\n                                return 'stopped';\n                            default:\n                                throw new Error('Should never happen');\n                        }\n                    };\n                    // set the transceiver direction to the offer direction\n                    this._peerConnection.getTransceivers().forEach((transceiver) => {\n                        if (transceiver.direction /* guarding, but should always be true */) {\n                            const offerDirection = directionToOffer(transceiver.direction);\n                            if (transceiver.direction !== offerDirection) {\n                                transceiver.direction = offerDirection;\n                            }\n                        }\n                    });\n                }\n                break;\n            case 'have-remote-offer':\n                // if we have a remote offer, assume we are creating a local answer\n                this.logger.debug('SessionDescriptionHandler.updateDirection - setting answer direction');\n                // FIXME: This is not the correct way to determine the answer direction as it is only\n                // considering first match in the offered SDP and using that to determine the answer direction.\n                // While that may be fine for our current use cases, it is not a generally correct approach.\n                {\n                    // determine the offered direction\n                    const offeredDirection = (() => {\n                        const description = this._peerConnection.remoteDescription;\n                        if (!description) {\n                            throw new Error('Failed to read remote offer');\n                        }\n                        const searchResult = /a=sendrecv\\r\\n|a=sendonly\\r\\n|a=recvonly\\r\\n|a=inactive\\r\\n/.exec(description.sdp);\n                        if (searchResult) {\n                            switch (searchResult[0]) {\n                                case 'a=inactive\\r\\n':\n                                    return 'inactive';\n                                case 'a=recvonly\\r\\n':\n                                    return 'recvonly';\n                                case 'a=sendonly\\r\\n':\n                                    return 'sendonly';\n                                case 'a=sendrecv\\r\\n':\n                                    return 'sendrecv';\n                                default:\n                                    throw new Error('Should never happen');\n                            }\n                        }\n                        return 'sendrecv';\n                    })();\n                    // determine the answer direction based on the offered direction and our hold state\n                    const answerDirection = (() => {\n                        switch (offeredDirection) {\n                            case 'inactive':\n                                return 'inactive';\n                            case 'recvonly':\n                                return 'sendonly';\n                            case 'sendonly':\n                                return options?.hold ? 'inactive' : 'recvonly';\n                            case 'sendrecv':\n                                return options?.hold ? 'sendonly' : 'sendrecv';\n                            default:\n                                throw new Error('Should never happen');\n                        }\n                    })();\n                    // set the transceiver direction to the answer direction\n                    this._peerConnection.getTransceivers().forEach((transceiver) => {\n                        if (transceiver.direction /* guarding, but should always be true */) {\n                            if (transceiver.direction !== 'stopped' && transceiver.direction !== answerDirection) {\n                                transceiver.direction = answerDirection;\n                            }\n                        }\n                    });\n                }\n                break;\n            case 'have-local-offer':\n            case 'have-local-pranswer':\n            case 'have-remote-pranswer':\n            case 'closed':\n            default:\n                return Promise.reject(new Error('Invalid signaling state ' + this._peerConnection.signalingState));\n        }\n        return Promise.resolve();\n    }\n    /**\n     * Called when ICE gathering completes and resolves any waiting promise.\n     */\n    iceGatheringComplete() {\n        this.logger.debug('SessionDescriptionHandler.iceGatheringComplete');\n        // clear timer if need be\n        if (this.iceGatheringCompleteTimeoutId !== undefined) {\n            this.logger.debug('SessionDescriptionHandler.iceGatheringComplete - clearing timeout');\n            clearTimeout(this.iceGatheringCompleteTimeoutId);\n            this.iceGatheringCompleteTimeoutId = undefined;\n        }\n        // resolve and cleanup promise if need be\n        if (this.iceGatheringCompletePromise !== undefined) {\n            this.logger.debug('SessionDescriptionHandler.iceGatheringComplete - resolving promise');\n            this.iceGatheringCompleteResolve?.();\n            this.iceGatheringCompletePromise = undefined;\n            this.iceGatheringCompleteResolve = undefined;\n            this.iceGatheringCompleteReject = undefined;\n        }\n    }\n    /**\n     * Wait for ICE gathering to complete.\n     * @param restart - If true, waits if current state is \"complete\" (waits for transition to \"complete\").\n     * @param timeout - Milliseconds after which waiting times out. No timeout if 0.\n     */\n    waitForIceGatheringComplete(restart = false, timeout = 0) {\n        this.logger.debug('SessionDescriptionHandler.waitForIceGatheringToComplete');\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error('Peer connection closed.'));\n        }\n        // guard already complete\n        if (!restart && this._peerConnection.iceGatheringState === 'complete') {\n            this.logger.debug('SessionDescriptionHandler.waitForIceGatheringToComplete - already complete');\n            return Promise.resolve();\n        }\n        // only one may be waiting, reject any prior\n        if (this.iceGatheringCompletePromise !== undefined) {\n            this.logger.debug('SessionDescriptionHandler.waitForIceGatheringToComplete - rejecting prior waiting promise');\n            this.iceGatheringCompleteReject?.(new Error('Promise superseded.'));\n            this.iceGatheringCompletePromise = undefined;\n            this.iceGatheringCompleteResolve = undefined;\n            this.iceGatheringCompleteReject = undefined;\n        }\n        this.iceGatheringCompletePromise = new Promise((resolve, reject) => {\n            this.iceGatheringCompleteResolve = resolve;\n            this.iceGatheringCompleteReject = reject;\n            if (timeout > 0) {\n                this.logger.debug('SessionDescriptionHandler.waitForIceGatheringToComplete - timeout in ' + timeout);\n                this.iceGatheringCompleteTimeoutId = setTimeout(() => {\n                    this.logger.debug('SessionDescriptionHandler.waitForIceGatheringToComplete - timeout');\n                    this.iceGatheringComplete();\n                }, timeout);\n            }\n        });\n        return this.iceGatheringCompletePromise;\n    }\n    /**\n     * Initializes the peer connection event handlers\n     */\n    initPeerConnectionEventHandlers() {\n        this.logger.debug('SessionDescriptionHandler.initPeerConnectionEventHandlers');\n        if (!this._peerConnection) {\n            throw new Error('Peer connection undefined.');\n        }\n        const peerConnection = this._peerConnection;\n        peerConnection.onconnectionstatechange = (event) => {\n            const newState = peerConnection.connectionState;\n            this.logger.debug(`SessionDescriptionHandler.onconnectionstatechange ${newState}`);\n            if (this._peerConnectionDelegate?.onconnectionstatechange) {\n                this._peerConnectionDelegate.onconnectionstatechange(event);\n            }\n        };\n        peerConnection.ondatachannel = (event) => {\n            this.logger.debug('SessionDescriptionHandler.ondatachannel');\n            this._dataChannel = event.channel;\n            if (this.onDataChannel) {\n                this.onDataChannel(this._dataChannel);\n            }\n            if (this._peerConnectionDelegate?.ondatachannel) {\n                this._peerConnectionDelegate.ondatachannel(event);\n            }\n        };\n        peerConnection.onicecandidate = (event) => {\n            this.logger.debug('SessionDescriptionHandler.onicecandidate');\n            if (this._peerConnectionDelegate?.onicecandidate) {\n                this._peerConnectionDelegate.onicecandidate(event);\n            }\n        };\n        peerConnection.onicecandidateerror = ((event) => {\n            this.logger.debug('SessionDescriptionHandler.onicecandidateerror');\n            if (this._peerConnectionDelegate?.onicecandidateerror) {\n                this._peerConnectionDelegate.onicecandidateerror(event);\n            }\n        });\n        peerConnection.oniceconnectionstatechange = (event) => {\n            const newState = peerConnection.iceConnectionState;\n            this.logger.debug(`SessionDescriptionHandler.oniceconnectionstatechange ${newState}`);\n            if (this._peerConnectionDelegate?.oniceconnectionstatechange) {\n                this._peerConnectionDelegate.oniceconnectionstatechange(event);\n            }\n        };\n        peerConnection.onicegatheringstatechange = (event) => {\n            const newState = peerConnection.iceGatheringState;\n            this.logger.debug(`SessionDescriptionHandler.onicegatheringstatechange ${newState}`);\n            if (newState === 'complete') {\n                this.iceGatheringComplete(); // complete waiting for ICE gathering to complete\n            }\n            if (this._peerConnectionDelegate?.onicegatheringstatechange) {\n                this._peerConnectionDelegate.onicegatheringstatechange(event);\n            }\n        };\n        peerConnection.onnegotiationneeded = (event) => {\n            this.logger.debug('SessionDescriptionHandler.onnegotiationneeded');\n            if (this._peerConnectionDelegate?.onnegotiationneeded) {\n                this._peerConnectionDelegate.onnegotiationneeded(event);\n            }\n        };\n        peerConnection.onsignalingstatechange = (event) => {\n            const newState = peerConnection.signalingState;\n            this.logger.debug(`SessionDescriptionHandler.onsignalingstatechange ${newState}`);\n            if (this._peerConnectionDelegate?.onsignalingstatechange) {\n                this._peerConnectionDelegate.onsignalingstatechange(event);\n            }\n        };\n        // onstatsended is no longer a part of PeerConnection as per the specs so removing it\n        // peerConnection.onstatsended = (event): void => {\n        //     this.logger.debug(`SessionDescriptionHandler.onstatsended`);\n        //     if (this._peerConnectionDelegate?.onstatsended) {\n        //         this._peerConnectionDelegate.onstatsended(event);\n        //     }\n        // };\n        peerConnection.ontrack = (event) => {\n            const kind = event.track.kind;\n            const enabled = event.track.enabled ? 'enabled' : 'disabled';\n            this.logger.debug(`SessionDescriptionHandler.ontrack ${kind} ${enabled}`);\n            this.setRemoteTrack(event.track);\n            if (this._peerConnectionDelegate?.ontrack) {\n                this._peerConnectionDelegate.ontrack(event);\n            }\n        };\n    }\n}\nexport function defaultPeerConnectionConfiguration() {\n    const config = {\n        bundlePolicy: 'balanced',\n        certificates: undefined,\n        iceCandidatePoolSize: 0,\n        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],\n        iceTransportPolicy: 'all',\n        rtcpMuxPolicy: 'require',\n    };\n    return config;\n}\nexport function defaultMediaStreamFactory() {\n    return (constraints) => {\n        // if no audio or video, return a media stream without tracks\n        if (!constraints.audio && !constraints.video) {\n            return Promise.resolve(new MediaStream());\n        }\n        // getUserMedia() is a powerful feature which can only be used in secure contexts; in insecure contexts,\n        // navigator.mediaDevices is undefined, preventing access to getUserMedia(). A secure context is, in short,\n        // a page loaded using HTTPS or the file:/// URL scheme, or a page loaded from localhost.\n        // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Privacy_and_security\n        if (navigator.mediaDevices === undefined) {\n            return Promise.reject(new Error('Media devices not available in insecure contexts.'));\n        }\n        return navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\nexport const defaultSessionDescriptionFactory = (session, options) => {\n    const mediaStreamFactory = defaultMediaStreamFactory();\n    // make sure we allow `0` to be passed in so timeout can be disabled\n    const iceGatheringTimeout = options?.iceGatheringTimeout !== undefined ? options?.iceGatheringTimeout : 5000;\n    // merge passed factory options into default session description configuration\n    const sessionDescriptionHandlerConfiguration = {\n        iceGatheringTimeout,\n        enableDscp: options.enableDscp,\n        peerConnectionConfiguration: {\n            ...defaultPeerConnectionConfiguration(),\n            ...options?.peerConnectionConfiguration,\n        },\n    };\n    const logger = session.userAgent.getLogger('sip.SessionDescriptionHandler');\n    return new SessionDescriptionHandler(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration);\n};\n","import { EventEmitter } from 'events';\nimport { TransportState } from 'sip.js';\nimport { Events } from './events';\nexport function createWebPhoneTransport(transport, options) {\n    transport.reconnectionAttempts = 0;\n    transport.sipErrorCodes = options.sipErrorCodes;\n    transport.servers = options.transportServers;\n    const eventEmitter = new EventEmitter();\n    transport.on = eventEmitter.on.bind(eventEmitter);\n    transport.off = eventEmitter.off.bind(eventEmitter);\n    transport.once = eventEmitter.once.bind(eventEmitter);\n    transport.addListener = eventEmitter.addListener.bind(eventEmitter);\n    transport.removeListener = eventEmitter.removeListener.bind(eventEmitter);\n    transport.removeAllListeners = eventEmitter.removeAllListeners.bind(eventEmitter);\n    transport.emit = eventEmitter.emit.bind(eventEmitter);\n    transport.mainProxy = options.transportServers[0];\n    transport.switchBackInterval = options.switchBackInterval;\n    transport.reconnectionTimeout = options.reconnectionTimeout;\n    transport.maxReconnectionAttempts = options.maxReconnectionAttempts;\n    transport.__afterWSConnected = __afterWSConnected.bind(transport);\n    transport.__clearSwitchBackToMainProxyTimer = __clearSwitchBackToMainProxyTimer.bind(transport);\n    transport.__computeRandomTimeout = __computeRandomTimeout.bind(transport);\n    transport.__connect = transport.connect;\n    transport.__isCurrentMainProxy = __isCurrentMainProxy.bind(transport);\n    transport.__onConnectedToBackup = __onConnectedToBackup.bind(transport);\n    transport.__onConnectedToMain = __onConnectedToMain.bind(transport);\n    transport.__resetServersErrorStatus = __resetServersErrorStatus.bind(transport);\n    transport.__scheduleSwitchBackToMainProxy = __scheduleSwitchBackToMainProxy.bind(transport);\n    transport.__setServerIsError = __setServerIsError.bind(transport);\n    transport.connect = __connect.bind(transport);\n    transport.getNextWsServer = getNextWsServer.bind(transport);\n    transport.isSipErrorCode = isSipErrorCode.bind(transport);\n    transport.noAvailableServers = noAvailableServers.bind(transport);\n    transport.onSipErrorCode = onSipErrorCode.bind(transport);\n    transport.reconnect = reconnect.bind(transport);\n    transport.stateChange.addListener((newState) => {\n        switch (newState) {\n            case TransportState.Connecting: {\n                transport.emit(Events.Transport.Connecting);\n                break;\n            }\n            case TransportState.Connected: {\n                transport.emit(Events.Transport.Connected);\n                transport.__afterWSConnected();\n                break;\n            }\n            case TransportState.Disconnecting: {\n                transport.emit(Events.Transport.Disconnecting);\n                break;\n            }\n            case TransportState.Disconnected: {\n                transport.emit(Events.Transport.Disconnected);\n                break;\n            }\n        }\n    });\n    return transport;\n}\nfunction __connect() {\n    return this.__connect().catch(async (e) => {\n        this.logger.error(`unable to establish connection to server ${this.server} - ${e.message}`);\n        this.emit(Events.Transport.ConnectionAttemptFailure, e); // Can we move to onTransportDisconnect?\n        await this.reconnect();\n    });\n}\nfunction __computeRandomTimeout(reconnectionAttempts = 1, randomMinInterval = 0, randomMaxInterval = 0) {\n    if (randomMinInterval < 0 || randomMaxInterval < 0 || reconnectionAttempts < 1) {\n        throw new Error('Arguments must be positive numbers');\n    }\n    const randomInterval = Math.floor(Math.random() * Math.abs(randomMaxInterval - randomMinInterval)) + randomMinInterval;\n    const retryOffset = ((reconnectionAttempts - 1) * (randomMinInterval + randomMaxInterval)) / 2;\n    return randomInterval + retryOffset;\n}\nfunction __setServerIsError(uri) {\n    this.servers.forEach((server) => {\n        if (server.uri === uri && !server.isError) {\n            server.isError = true;\n        }\n    });\n}\nfunction __resetServersErrorStatus() {\n    this.servers.forEach((server) => {\n        server.isError = false;\n    });\n}\nfunction __isCurrentMainProxy() {\n    return this.server === this.servers[0].uri;\n}\nfunction __afterWSConnected() {\n    this.__isCurrentMainProxy() ? this.__onConnectedToMain() : this.__onConnectedToBackup();\n}\nfunction __onConnectedToMain() {\n    this.__clearSwitchBackToMainProxyTimer();\n}\nfunction __onConnectedToBackup() {\n    if (!this.switchBackToMainProxyTimer) {\n        this.__scheduleSwitchBackToMainProxy();\n    }\n}\nfunction __scheduleSwitchBackToMainProxy() {\n    const randomInterval = 15 * 60 * 1000; // 15 min\n    let switchBackInterval = this.switchBackInterval ? this.switchBackInterval * 1000 : null;\n    // Add random time to expand clients connections in time;\n    if (switchBackInterval) {\n        switchBackInterval += this.__computeRandomTimeout(1, 0, randomInterval);\n        this.logger.warn('Try to switch back to main proxy after ' + Math.round(switchBackInterval / 1000 / 60) + ' min');\n        this.switchBackToMainProxyTimer = setTimeout(() => {\n            this.switchBackToMainProxyTimer = null;\n            this.logger.warn('switchBack initiated');\n            this.emit(Events.Transport.SwitchBackToMainProxy);\n            // FIXME: Why is force reconnect not called here and the client is made to do that?\n        }, switchBackInterval);\n    }\n    else {\n        this.logger.warn('switchBackInterval is not set. Will be switched with next provision update ');\n    }\n}\nfunction __clearSwitchBackToMainProxyTimer() {\n    if (this.switchBackToMainProxyTimer) {\n        clearTimeout(this.switchBackToMainProxyTimer);\n        this.switchBackToMainProxyTimer = null;\n    }\n}\nasync function reconnect(forceReconnectToMain) {\n    if (this.reconnectionAttempts > 0) {\n        this.logger.warn(`Reconnection attempt ${this.reconnectionAttempts} failed`);\n    }\n    if (this.reconnectTimer) {\n        this.logger.warn('already trying to reconnect');\n        return;\n    }\n    if (forceReconnectToMain) {\n        this.logger.warn('forcing connect to main WS server');\n        await this.disconnect();\n        this.server = this.getNextWsServer(true).uri;\n        this.reconnectionAttempts = 0;\n        await this.connect();\n        return;\n    }\n    if (this.isConnected()) {\n        this.logger.warn('attempted to reconnect while connected - forcing disconnect');\n        await this.disconnect();\n        await this.reconnect();\n        return;\n    }\n    if (this.noAvailableServers()) {\n        this.logger.warn('no available WebSocket servers left');\n        this.emit(Events.Transport.Closed);\n        this.__resetServersErrorStatus();\n        this.server = this.getNextWsServer(true).uri;\n        this.__clearSwitchBackToMainProxyTimer();\n        return;\n    }\n    this.reconnectionAttempts += 1;\n    if (this.reconnectionAttempts > this.maxReconnectionAttempts) {\n        this.logger.warn(`maximum reconnection attempts for WebSocket ${this.server}`);\n        this.logger.warn(`transport ${this.server} failed`);\n        this.__setServerIsError(this.server);\n        this.emit(Events.Transport.ConnectionFailure);\n        const nextServer = this.getNextWsServer();\n        if (!nextServer) {\n            // No more servers available to try connecting to\n            this.logger.error('unable to connect to any transport');\n            return;\n        }\n        this.configuration.server = nextServer.uri;\n        this.reconnectionAttempts = 0;\n        await this.connect();\n    }\n    else {\n        const randomMinInterval = (this.reconnectionTimeout - 2) * 1000;\n        const randomMaxInterval = (this.reconnectionTimeout + 2) * 1000;\n        this.nextReconnectInterval = this.__computeRandomTimeout(this.reconnectionAttempts, randomMinInterval, randomMaxInterval);\n        this.logger.warn(`trying to reconnect to WebSocket ${this.server} (reconnection attempt: ${this.reconnectionAttempts})`);\n        this.reconnectTimer = setTimeout(() => {\n            this.reconnectTimer = undefined;\n            this.connect().then(() => {\n                this.reconnectionAttempts = 0;\n            });\n        }, this.nextReconnectInterval);\n        this.logger.warn(`next reconnection attempt in: ${Math.round(this.nextReconnectInterval / 1000)} seconds.`);\n    }\n}\nfunction getNextWsServer(force = false) {\n    // Adding the force check because otherwise it will not bypass error check\n    if (!force && this.noAvailableServers()) {\n        this.logger.warn('attempted to get next ws server but there are no available ws servers left');\n        return;\n    }\n    const candidates = force ? this.servers : this.servers.filter(({ isError }) => !isError);\n    return candidates[0];\n}\nfunction noAvailableServers() {\n    return this.servers.every(({ isError }) => isError);\n}\nfunction isSipErrorCode(statusCode) {\n    if (!statusCode) {\n        return false;\n    }\n    if (!this.sipErrorCodes) {\n        return false;\n    }\n    return this.sipErrorCodes.indexOf(statusCode.toString()) !== -1;\n}\nasync function onSipErrorCode() {\n    this.logger.warn('Error received from the server. Disconnecting from the proxy');\n    this.__setServerIsError(this.server);\n    this.emit(Events.Transport.ConnectionFailure);\n    this.reconnectionAttempts = 0;\n    return this.reconnect();\n}\n","import { EventEmitter } from 'events';\nimport { UserAgent, UserAgentState, Registerer, RegistererState, Inviter, Messager, } from 'sip.js';\nimport { createWebPhoneTransport } from './transport';\nimport { AudioHelper } from './audioHelper';\nimport { Events } from './events';\nimport { onSessionDescriptionHandlerCreated, patchIncomingWebphoneSession, patchWebphoneSession, } from './session';\nimport { patchUserAgentCore } from './userAgentCore';\n/** @ignore */\n// eslint-disable-next-line max-params\nexport function createWebPhoneUserAgent(configuration, sipInfo, options, id) {\n    const extraConfiguration = {\n        delegate: {\n            onConnect: () => userAgent.register(),\n            onInvite: (invitation) => {\n                userAgent.audioHelper.playIncoming(true);\n                invitation.delegate = {};\n                invitation.delegate.onSessionDescriptionHandler = () => onSessionDescriptionHandlerCreated(invitation);\n                patchWebphoneSession(invitation);\n                patchIncomingWebphoneSession(invitation);\n                invitation.logger.log('UA received incoming call invite');\n                invitation.sendReceiveConfirm();\n                userAgent.emit(Events.UserAgent.Invite, invitation);\n            },\n            onNotify: (notification) => {\n                const event = notification.request.getHeader('Event');\n                if (event === '') {\n                    userAgent.emit(Events.UserAgent.ProvisionUpdate);\n                }\n                userAgent.logger.log('UA received notify');\n                notification.accept();\n            },\n        },\n    };\n    const extendedConfiguration = {\n        ...extraConfiguration,\n        ...configuration,\n    };\n    const userAgent = new UserAgent(extendedConfiguration);\n    const eventEmitter = new EventEmitter();\n    userAgent.on = eventEmitter.on.bind(eventEmitter);\n    userAgent.off = eventEmitter.off.bind(eventEmitter);\n    userAgent.once = eventEmitter.once.bind(eventEmitter);\n    userAgent.addListener = eventEmitter.addListener.bind(eventEmitter);\n    userAgent.removeListener = eventEmitter.removeListener.bind(eventEmitter);\n    userAgent.removeAllListeners = eventEmitter.removeAllListeners.bind(eventEmitter);\n    userAgent.defaultHeaders = [`P-rc-endpoint-id: ${id}`, `Client-id: ${options.clientId}`];\n    userAgent.regId = options.regId;\n    userAgent.media = {};\n    userAgent.enableQos = options.enableQos;\n    userAgent.enableMediaReportLogging = options.enableMediaReportLogging;\n    userAgent.qosCollectInterval = options.qosCollectInterval;\n    if (options.media?.remote && options.media.local) {\n        userAgent.media.remote = options.media.remote;\n        userAgent.media.local = options.media.local;\n    }\n    else {\n        userAgent.media = undefined;\n    }\n    userAgent.registerer = new Registerer(userAgent, {\n        regId: userAgent.regId,\n        instanceId: userAgent.instanceId,\n        extraHeaders: userAgent.defaultHeaders,\n    });\n    userAgent.sipInfo = sipInfo;\n    userAgent.modifiers = options.modifiers;\n    userAgent.constraints = options.mediaConstraints;\n    userAgent.earlyMedia = options.earlyMedia;\n    userAgent.audioHelper = new AudioHelper(options.audioHelper);\n    userAgent.onSession = options.onSession;\n    userAgent._transport = createWebPhoneTransport(userAgent.transport, options);\n    userAgent.onTransportDisconnect = onTransportDisconnect.bind(userAgent);\n    userAgent.emit = eventEmitter.emit.bind(eventEmitter);\n    userAgent.register = register.bind(userAgent);\n    userAgent.unregister = unregister.bind(userAgent);\n    userAgent.invite = invite.bind(userAgent);\n    userAgent.sendMessage = sendMessage.bind(userAgent);\n    userAgent.createRcMessage = createRcMessage.bind(userAgent);\n    userAgent.switchFrom = switchFrom.bind(userAgent);\n    patchUserAgentCore(userAgent);\n    userAgent.start();\n    userAgent.stateChange.addListener((newState) => {\n        switch (newState) {\n            case UserAgentState.Started: {\n                userAgent.emit(Events.UserAgent.Started);\n                break;\n            }\n            case UserAgentState.Stopped: {\n                userAgent.emit(Events.UserAgent.Stopped);\n                break;\n            }\n        }\n    });\n    userAgent.registerer.stateChange.addListener((newState) => {\n        switch (newState) {\n            case RegistererState.Registered: {\n                userAgent.emit(Events.UserAgent.Registered);\n                break;\n            }\n            case RegistererState.Unregistered: {\n                userAgent.emit(Events.UserAgent.Unregistered);\n                break;\n            }\n        }\n    });\n    return userAgent;\n}\nfunction onTransportDisconnect(error) {\n    // Patch it so that reconnection is managed by WebPhoneTransport\n    if (this.state === UserAgentState.Stopped) {\n        return;\n    }\n    if (this.delegate?.onDisconnect) {\n        this.delegate.onDisconnect(error);\n    }\n    if (error) {\n        this.transport.reconnect();\n    }\n}\nfunction createRcMessage(options) {\n    options.body = options.body || '';\n    return ('<Msg>' +\n        '<Hdr SID=\"' +\n        options.sid +\n        '\" Req=\"' +\n        options.request +\n        '\" From=\"' +\n        options.from +\n        '\" To=\"' +\n        options.to +\n        '\" Cmd=\"' +\n        options.reqid +\n        '\"/> ' +\n        '<Bdy Cln=\"' +\n        this.sipInfo.authorizationId +\n        '\" ' +\n        options.body +\n        '/>' +\n        '</Msg>');\n}\nfunction sendMessage(_to, messageData) {\n    const extraHeaders = [`P-rc-ws: ${this.contact}`];\n    // For some reason, UserAgent.makeURI is unable to parse username starting with #\n    // Fix in later release if this is fixed by SIP.js\n    let to = _to;\n    const [user] = to.split('@');\n    to = to.startsWith('#') ? `sip:${to.substring(1)}` : `sip:${to}`;\n    const uri = UserAgent.makeURI(to);\n    uri.user = user;\n    const messager = new Messager(this, uri, messageData, 'x-rc/agent', {\n        extraHeaders,\n    });\n    return new Promise((resolve, reject) => {\n        messager.message({\n            requestDelegate: {\n                onAccept: resolve,\n                onReject: reject,\n            },\n        });\n    });\n}\nasync function register() {\n    await this.registerer.register({\n        requestDelegate: {\n            onReject: (response) => {\n                if (!response) {\n                    return;\n                }\n                if (this.transport.isSipErrorCode(response.message.statusCode)) {\n                    this.transport.onSipErrorCode();\n                }\n                this.emit(Events.UserAgent.RegistrationFailed, response);\n                this.logger.warn('UA Registration Failed');\n            },\n        },\n    });\n}\nasync function unregister() {\n    await this.registerer.unregister();\n}\nfunction invite(number, options = {}) {\n    const inviterOptions = {};\n    inviterOptions.extraHeaders = [\n        ...(options.extraHeaders || []),\n        ...this.defaultHeaders,\n        `P-Asserted-Identity: sip:${(options.fromNumber || this.sipInfo.username) + '@' + this.sipInfo.domain}`,\n        ...(options.homeCountryId ? [`P-rc-country-id: ${options.homeCountryId}`] : []),\n    ];\n    options.RTCConstraints = options.RTCConstraints || {\n        ...this.constraints,\n        optional: [{ DtlsSrtpKeyAgreement: 'true' }],\n    };\n    inviterOptions.sessionDescriptionHandlerModifiers = this.modifiers;\n    inviterOptions.sessionDescriptionHandlerOptions = {\n        constraints: options.RTCConstraints,\n    };\n    inviterOptions.earlyMedia = this.earlyMedia;\n    inviterOptions.delegate = {\n        onSessionDescriptionHandler: () => onSessionDescriptionHandlerCreated(inviter),\n        onNotify: (notification) => notification.accept(),\n    };\n    this.audioHelper.playOutgoing(true);\n    this.logger.log(`Invite to ${number} created with playOutgoing set to true`);\n    const inviter = new Inviter(this, UserAgent.makeURI(`sip:${number}@${this.sipInfo.domain}`), inviterOptions);\n    inviter\n        .invite({\n        requestDelegate: {\n            onAccept: (inviteResponse) => {\n                inviter.startTime = new Date();\n                inviter.emit(Events.Session.Accepted, inviteResponse.message);\n            },\n            onProgress: (inviteResponse) => {\n                inviter.emit(Events.Session.Progress, inviteResponse.message);\n            },\n        },\n    })\n        .then(() => this.emit(Events.UserAgent.InviteSent, inviter))\n        .catch((e) => {\n        if (e.message.indexOf('Permission denied') > -1) {\n            inviter.emit(Events.Session.UserMediaFailed);\n        }\n        throw e;\n    });\n    patchWebphoneSession(inviter);\n    return inviter;\n}\n/**\n * Support to switch call from other device to current web phone device\n * need active call information from details presence API for switching\n * https://developers.ringcentral.com/api-reference/Detailed-Extension-Presence-with-SIP-Event\n */\nfunction switchFrom(activeCall, options = {}) {\n    const replaceHeaders = [\n        `Replaces: ${activeCall.id};to-tag=${activeCall.sipData.fromTag};from-tag=${activeCall.sipData.toTag}`,\n        'RC-call-type: replace',\n    ];\n    const [toNumber, fromNumber] = activeCall.direction === 'Outbound' ? [activeCall.to, activeCall.from] : [activeCall.from, activeCall.to];\n    options.extraHeaders = (options.extraHeaders || []).concat(replaceHeaders);\n    options.fromNumber = options.fromNumber || fromNumber;\n    const inviterOptions = {\n        extraHeaders: options.extraHeaders,\n        sessionDescriptionHandlerOptions: {\n            constraints: options.RTCConstraints || this.constraints,\n        },\n    };\n    return this.invite(toNumber, inviterOptions);\n}\n","import { EventEmitter } from 'events';\nimport { C } from 'sip.js/lib/core';\nimport { Events } from './events';\n/** @ignore */\nexport function patchUserAgentCore(userAgent) {\n    const userAgentCore = userAgent.userAgentCore;\n    const eventEmitter = new EventEmitter();\n    userAgentCore.on = eventEmitter.on.bind(eventEmitter);\n    userAgentCore.off = eventEmitter.off.bind(eventEmitter);\n    userAgentCore.addListener = eventEmitter.addListener.bind(eventEmitter);\n    userAgentCore.removeListener = eventEmitter.removeListener.bind(eventEmitter);\n    userAgentCore.emit = eventEmitter.emit.bind(eventEmitter);\n    userAgentCore._receiveIncomingRequestFromTransport = userAgentCore.receiveIncomingRequestFromTransport.bind(userAgent.userAgentCore);\n    userAgentCore.receiveIncomingRequestFromTransport = receiveIncomingRequestFromTransport.bind(userAgent.userAgentCore);\n}\nfunction receiveIncomingRequestFromTransport(message) {\n    switch (message.method) {\n        case C.UPDATE: {\n            this.logger.log('Receive UPDATE request. Do nothing just return 200 OK');\n            this.replyStateless(message, { statusCode: 200 });\n            this.emit(Events.Session.UpdateReceived, message);\n            return;\n        }\n        case C.INFO: {\n            // For the Move2RCV request from server\n            const content = getIncomingInfoContent(message);\n            if (content?.request?.reqId && content?.request?.command === 'move' && content?.request?.target === 'rcv') {\n                this.replyStateless(message, { statusCode: 200 });\n                this.emit(Events.Session.MoveToRcv, content.request);\n                return;\n            }\n            // For other SIP INFO from server\n            this.emit('RC_SIP_INFO', message);\n            // SIP.js does not support application/json content type, so we monkey override its behavior in this case\n            const contentType = message.getHeader('content-type');\n            if (contentType.match(/^application\\/json/i)) {\n                this.replyStateless(message, { statusCode: 200 });\n                return;\n            }\n            break;\n        }\n    }\n    return this._receiveIncomingRequestFromTransport(message);\n}\nfunction getIncomingInfoContent(message) {\n    if (!message?.body) {\n        return {};\n    }\n    let ret = {};\n    try {\n        ret = JSON.parse(message.body);\n    }\n    catch (e) {\n        return {};\n    }\n    return ret;\n}\n","export const uuid = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n});\nexport const extend = (dst = {}, src = {}) => Object.assign(dst || {}, src || {});\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE_sip_js__;","/**\n * {@link Session} state.\n *\n * @remarks\n * The {@link Session} behaves in a deterministic manner according to the following\n * Finite State Machine (FSM).\n * ```txt\n *                   ___________________________________________________________\n *                  |  ____________________________________________             |\n *                  | |            ____________________________    |            |\n * Session          | |           |                            v   v            v\n * Constructed -> Initial -> Establishing -> Established -> Terminating -> Terminated\n *                                |               |___________________________^   ^\n *                                |_______________________________________________|\n * ```\n * @public\n */\nexport var SessionState;\n(function (SessionState) {\n    /**\n     * If `Inviter`, INVITE not sent yet.\n     * If `Invitation`, received INVITE (but no final response sent yet).\n     */\n    SessionState[\"Initial\"] = \"Initial\";\n    /**\n     * If `Inviter`, sent INVITE and waiting for a final response.\n     * If `Invitation`, received INVITE and attempting to send 200 final response (but has not sent it yet).\n     */\n    SessionState[\"Establishing\"] = \"Establishing\";\n    /**\n     * If `Inviter`, sent INVITE and received 200 final response and sent ACK.\n     * If `Invitation`, received INVITE and sent 200 final response.\n     */\n    SessionState[\"Established\"] = \"Established\";\n    /**\n     * If `Inviter`, sent INVITE, sent CANCEL and now waiting for 487 final response to ACK (or 200 to ACK & BYE).\n     * If `Invitation`, received INVITE, sent 200 final response and now waiting on ACK and upon receipt will attempt BYE\n     * (as the protocol specification requires, before sending a BYE we must receive the ACK - so we are waiting).\n     */\n    SessionState[\"Terminating\"] = \"Terminating\";\n    /**\n     * If `Inviter`, sent INVITE and received non-200 final response (or sent/received BYE after receiving 200).\n     * If `Invitation`, received INVITE and sent non-200 final response (or sent/received BYE after sending 200).\n     */\n    SessionState[\"Terminated\"] = \"Terminated\";\n})(SessionState = SessionState || (SessionState = {}));\n","/**\n * Log levels.\n * @public\n */\nexport var Levels;\n(function (Levels) {\n    Levels[Levels[\"error\"] = 0] = \"error\";\n    Levels[Levels[\"warn\"] = 1] = \"warn\";\n    Levels[Levels[\"log\"] = 2] = \"log\";\n    Levels[Levels[\"debug\"] = 3] = \"debug\";\n})(Levels = Levels || (Levels = {}));\n","import { IncomingRequestMessage } from \"./incoming-request-message.js\";\nimport { IncomingResponseMessage } from \"./incoming-response-message.js\";\nimport { OutgoingRequestMessage } from \"./outgoing-request-message.js\";\n// If the Content-Disposition header field is missing, bodies of\n// Content-Type application/sdp imply the disposition \"session\", while\n// other content types imply \"render\".\n// https://tools.ietf.org/html/rfc3261#section-13.2.1\nfunction contentTypeToContentDisposition(contentType) {\n    if (contentType === \"application/sdp\") {\n        return \"session\";\n    }\n    else {\n        return \"render\";\n    }\n}\n/**\n * Create a Body given a legacy body type.\n * @param bodyLegacy - Body Object\n * @internal\n */\nexport function fromBodyLegacy(bodyLegacy) {\n    const content = typeof bodyLegacy === \"string\" ? bodyLegacy : bodyLegacy.body;\n    const contentType = typeof bodyLegacy === \"string\" ? \"application/sdp\" : bodyLegacy.contentType;\n    const contentDisposition = contentTypeToContentDisposition(contentType);\n    const body = { contentDisposition, contentType, content };\n    return body;\n}\n/**\n * User-Defined Type Guard for Body.\n * @param body - Body to check.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isBody(body) {\n    return body &&\n        typeof body.content === \"string\" &&\n        typeof body.contentType === \"string\" &&\n        body.contentDisposition === undefined\n        ? true\n        : typeof body.contentDisposition === \"string\";\n}\n/**\n * Given a message, get a normalized body.\n * The content disposition is inferred if not set.\n * @param message - The message.\n * @internal\n */\nexport function getBody(message) {\n    let contentDisposition;\n    let contentType;\n    let content;\n    // We're in UAS role, receiving incoming request\n    if (message instanceof IncomingRequestMessage) {\n        if (message.body) {\n            // FIXME: Parsing needs typing\n            const parse = message.parseHeader(\"Content-Disposition\");\n            contentDisposition = parse ? parse.type : undefined;\n            contentType = message.parseHeader(\"Content-Type\");\n            content = message.body;\n        }\n    }\n    // We're in UAC role, receiving incoming response\n    if (message instanceof IncomingResponseMessage) {\n        if (message.body) {\n            // FIXME: Parsing needs typing\n            const parse = message.parseHeader(\"Content-Disposition\");\n            contentDisposition = parse ? parse.type : undefined;\n            contentType = message.parseHeader(\"Content-Type\");\n            content = message.body;\n        }\n    }\n    // We're in UAC role, sending outgoing request\n    if (message instanceof OutgoingRequestMessage) {\n        if (message.body) {\n            contentDisposition = message.getHeader(\"Content-Disposition\");\n            contentType = message.getHeader(\"Content-Type\");\n            if (typeof message.body === \"string\") {\n                // FIXME: OutgoingRequest should not allow a \"string\" body without a \"Content-Type\" header.\n                if (!contentType) {\n                    throw new Error(\"Header content type header does not equal body content type.\");\n                }\n                content = message.body;\n            }\n            else {\n                // FIXME: OutgoingRequest should not allow the \"Content-Type\" header not to match th body content type\n                if (contentType && contentType !== message.body.contentType) {\n                    throw new Error(\"Header content type header does not equal body content type.\");\n                }\n                contentType = message.body.contentType;\n                content = message.body.body;\n            }\n        }\n    }\n    // We're in UAS role, sending outgoing response\n    if (isBody(message)) {\n        contentDisposition = message.contentDisposition;\n        contentType = message.contentType;\n        content = message.content;\n    }\n    // No content, no body.\n    if (!content) {\n        return undefined;\n    }\n    if (contentType && !contentDisposition) {\n        contentDisposition = contentTypeToContentDisposition(contentType);\n    }\n    if (!contentDisposition) {\n        throw new Error(\"Content disposition undefined.\");\n    }\n    if (!contentType) {\n        throw new Error(\"Content type undefined.\");\n    }\n    return {\n        contentDisposition,\n        contentType,\n        content\n    };\n}\n","import { Grammar } from \"../../grammar/grammar.js\";\nimport { headerize } from \"./utils.js\";\n/**\n * Incoming message.\n * @public\n */\nexport class IncomingMessage {\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.headers = {};\n    }\n    /**\n     * Insert a header of the given name and value into the last position of the\n     * header array.\n     * @param name - header name\n     * @param value - header value\n     */\n    addHeader(name, value) {\n        const header = { raw: value };\n        name = headerize(name);\n        if (this.headers[name]) {\n            this.headers[name].push(header);\n        }\n        else {\n            this.headers[name] = [header];\n        }\n    }\n    /**\n     * Get the value of the given header name at the given position.\n     * @param name - header name\n     * @returns Returns the specified header, undefined if header doesn't exist.\n     */\n    getHeader(name) {\n        const header = this.headers[headerize(name)];\n        if (header) {\n            if (header[0]) {\n                return header[0].raw;\n            }\n        }\n        else {\n            return;\n        }\n    }\n    /**\n     * Get the header/s of the given name.\n     * @param name - header name\n     * @returns Array - with all the headers of the specified name.\n     */\n    getHeaders(name) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const header = this.headers[headerize(name)];\n        const result = [];\n        if (!header) {\n            return [];\n        }\n        for (const headerPart of header) {\n            result.push(headerPart.raw);\n        }\n        return result;\n    }\n    /**\n     * Verify the existence of the given header.\n     * @param name - header name\n     * @returns true if header with given name exists, false otherwise\n     */\n    hasHeader(name) {\n        return !!this.headers[headerize(name)];\n    }\n    /**\n     * Parse the given header on the given index.\n     * @param name - header name\n     * @param idx - header index\n     * @returns Parsed header object, undefined if the\n     *   header is not present or in case of a parsing error.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parseHeader(name, idx = 0) {\n        name = headerize(name);\n        if (!this.headers[name]) {\n            // this.logger.log(\"header '\" + name + \"' not present\");\n            return;\n        }\n        else if (idx >= this.headers[name].length) {\n            // this.logger.log(\"not so many '\" + name + \"' headers present\");\n            return;\n        }\n        const header = this.headers[name][idx];\n        const value = header.raw;\n        if (header.parsed) {\n            return header.parsed;\n        }\n        // substitute '-' by '_' for grammar rule matching.\n        const parsed = Grammar.parse(value, name.replace(/-/g, \"_\"));\n        if (parsed === -1) {\n            this.headers[name].splice(idx, 1); // delete from headers\n            // this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n            return;\n        }\n        else {\n            header.parsed = parsed;\n            return parsed;\n        }\n    }\n    /**\n     * Message Header attribute selector. Alias of parseHeader.\n     * @param name - header name\n     * @param idx - header index\n     * @returns Parsed header object, undefined if the\n     *   header is not present or in case of a parsing error.\n     *\n     * @example\n     * message.s('via',3).port\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    s(name, idx = 0) {\n        return this.parseHeader(name, idx);\n    }\n    /**\n     * Replace the value of the given header by the value.\n     * @param name - header name\n     * @param value - header value\n     */\n    setHeader(name, value) {\n        this.headers[headerize(name)] = [{ raw: value }];\n    }\n    toString() {\n        return this.data;\n    }\n}\n","import { IncomingMessage } from \"./incoming-message.js\";\n/**\n * Incoming request message.\n * @public\n */\nexport class IncomingRequestMessage extends IncomingMessage {\n    constructor() {\n        super();\n    }\n}\n","import { IncomingMessage } from \"./incoming-message.js\";\n/**\n * Incoming response message.\n * @public\n */\nexport class IncomingResponseMessage extends IncomingMessage {\n    constructor() {\n        super();\n    }\n}\n","/* eslint-disable @typescript-eslint/no-namespace */\n/**\n * SIP Methods\n * @internal\n */\nexport var C;\n(function (C) {\n    C.ACK = \"ACK\";\n    C.BYE = \"BYE\";\n    C.CANCEL = \"CANCEL\";\n    C.INFO = \"INFO\";\n    C.INVITE = \"INVITE\";\n    C.MESSAGE = \"MESSAGE\";\n    C.NOTIFY = \"NOTIFY\";\n    C.OPTIONS = \"OPTIONS\";\n    C.REGISTER = \"REGISTER\";\n    C.UPDATE = \"UPDATE\";\n    C.SUBSCRIBE = \"SUBSCRIBE\";\n    C.PUBLISH = \"PUBLISH\";\n    C.REFER = \"REFER\";\n    C.PRACK = \"PRACK\";\n})(C = C || (C = {}));\n","import { NameAddrHeader } from \"../../grammar/name-addr-header.js\";\nimport { createRandomToken, headerize, newTag, utf8Length } from \"./utils.js\";\n/**\n * Outgoing SIP request message.\n * @public\n */\nexport class OutgoingRequestMessage {\n    constructor(method, ruri, fromURI, toURI, options, extraHeaders, body) {\n        this.headers = {};\n        this.extraHeaders = [];\n        // Initialize default options\n        this.options = OutgoingRequestMessage.getDefaultOptions();\n        // Options - merge a deep copy\n        if (options) {\n            this.options = Object.assign(Object.assign({}, this.options), options);\n            if (this.options.optionTags && this.options.optionTags.length) {\n                this.options.optionTags = this.options.optionTags.slice();\n            }\n            if (this.options.routeSet && this.options.routeSet.length) {\n                this.options.routeSet = this.options.routeSet.slice();\n            }\n        }\n        // Extra headers - deep copy\n        if (extraHeaders && extraHeaders.length) {\n            this.extraHeaders = extraHeaders.slice();\n        }\n        // Body - deep copy\n        if (body) {\n            // TODO: internal representation should be Body\n            // this.body = { ...body };\n            this.body = {\n                body: body.content,\n                contentType: body.contentType\n            };\n        }\n        // Method\n        this.method = method;\n        // RURI\n        this.ruri = ruri.clone();\n        // From\n        this.fromURI = fromURI.clone();\n        this.fromTag = this.options.fromTag ? this.options.fromTag : newTag();\n        this.from = OutgoingRequestMessage.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag);\n        // To\n        this.toURI = toURI.clone();\n        this.toTag = this.options.toTag;\n        this.to = OutgoingRequestMessage.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag);\n        // Call-ID\n        this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + createRandomToken(15);\n        // CSeq\n        this.cseq = this.options.cseq;\n        // The relative order of header fields with different field names is not\n        // significant.  However, it is RECOMMENDED that header fields which are\n        // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n        // Max-Forwards, and Proxy-Authorization, for example) appear towards\n        // the top of the message to facilitate rapid parsing.\n        // https://tools.ietf.org/html/rfc3261#section-7.3.1\n        this.setHeader(\"route\", this.options.routeSet);\n        this.setHeader(\"via\", \"\");\n        this.setHeader(\"to\", this.to.toString());\n        this.setHeader(\"from\", this.from.toString());\n        this.setHeader(\"cseq\", this.cseq + \" \" + this.method);\n        this.setHeader(\"call-id\", this.callId);\n        this.setHeader(\"max-forwards\", \"70\");\n    }\n    /** Get a copy of the default options. */\n    static getDefaultOptions() {\n        return {\n            callId: \"\",\n            callIdPrefix: \"\",\n            cseq: 1,\n            toDisplayName: \"\",\n            toTag: \"\",\n            fromDisplayName: \"\",\n            fromTag: \"\",\n            forceRport: false,\n            hackViaTcp: false,\n            optionTags: [\"outbound\"],\n            routeSet: [],\n            userAgentString: \"sip.js\",\n            viaHost: \"\"\n        };\n    }\n    static makeNameAddrHeader(uri, displayName, tag) {\n        const parameters = {};\n        if (tag) {\n            parameters.tag = tag;\n        }\n        return new NameAddrHeader(uri, displayName, parameters);\n    }\n    /**\n     * Get the value of the given header name at the given position.\n     * @param name - header name\n     * @returns Returns the specified header, undefined if header doesn't exist.\n     */\n    getHeader(name) {\n        const header = this.headers[headerize(name)];\n        if (header) {\n            if (header[0]) {\n                return header[0];\n            }\n        }\n        else {\n            const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n            for (const exHeader of this.extraHeaders) {\n                if (regexp.test(exHeader)) {\n                    return exHeader.substring(exHeader.indexOf(\":\") + 1).trim();\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Get the header/s of the given name.\n     * @param name - header name\n     * @returns Array with all the headers of the specified name.\n     */\n    getHeaders(name) {\n        const result = [];\n        const headerArray = this.headers[headerize(name)];\n        if (headerArray) {\n            for (const headerPart of headerArray) {\n                result.push(headerPart);\n            }\n        }\n        else {\n            const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n            for (const exHeader of this.extraHeaders) {\n                if (regexp.test(exHeader)) {\n                    result.push(exHeader.substring(exHeader.indexOf(\":\") + 1).trim());\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Verify the existence of the given header.\n     * @param name - header name\n     * @returns true if header with given name exists, false otherwise\n     */\n    hasHeader(name) {\n        if (this.headers[headerize(name)]) {\n            return true;\n        }\n        else {\n            const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n            for (const extraHeader of this.extraHeaders) {\n                if (regexp.test(extraHeader)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Replace the the given header by the given value.\n     * @param name - header name\n     * @param value - header value\n     */\n    setHeader(name, value) {\n        this.headers[headerize(name)] = value instanceof Array ? value : [value];\n    }\n    /**\n     * The Via header field indicates the transport used for the transaction\n     * and identifies the location where the response is to be sent.  A Via\n     * header field value is added only after the transport that will be\n     * used to reach the next hop has been selected (which may involve the\n     * usage of the procedures in [4]).\n     *\n     * When the UAC creates a request, it MUST insert a Via into that\n     * request.  The protocol name and protocol version in the header field\n     * MUST be SIP and 2.0, respectively.  The Via header field value MUST\n     * contain a branch parameter.  This parameter is used to identify the\n     * transaction created by that request.  This parameter is used by both\n     * the client and the server.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.1.7\n     * @param branchParameter - The branch parameter.\n     * @param transport - The sent protocol transport.\n     */\n    setViaHeader(branch, transport) {\n        // FIXME: Hack\n        if (this.options.hackViaTcp) {\n            transport = \"TCP\";\n        }\n        let via = \"SIP/2.0/\" + transport;\n        via += \" \" + this.options.viaHost + \";branch=\" + branch;\n        if (this.options.forceRport) {\n            via += \";rport\";\n        }\n        this.setHeader(\"via\", via);\n        this.branch = branch;\n    }\n    toString() {\n        let msg = \"\";\n        msg += this.method + \" \" + this.ruri.toRaw() + \" SIP/2.0\\r\\n\";\n        for (const header in this.headers) {\n            if (this.headers[header]) {\n                for (const headerPart of this.headers[header]) {\n                    msg += header + \": \" + headerPart + \"\\r\\n\";\n                }\n            }\n        }\n        for (const header of this.extraHeaders) {\n            msg += header.trim() + \"\\r\\n\";\n        }\n        msg += \"Supported: \" + this.options.optionTags.join(\", \") + \"\\r\\n\";\n        msg += \"User-Agent: \" + this.options.userAgentString + \"\\r\\n\";\n        if (this.body) {\n            if (typeof this.body === \"string\") {\n                msg += \"Content-Length: \" + utf8Length(this.body) + \"\\r\\n\\r\\n\";\n                msg += this.body;\n            }\n            else {\n                if (this.body.body && this.body.contentType) {\n                    msg += \"Content-Type: \" + this.body.contentType + \"\\r\\n\";\n                    msg += \"Content-Length: \" + utf8Length(this.body.body) + \"\\r\\n\\r\\n\";\n                    msg += this.body.body;\n                }\n                else {\n                    msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n                }\n            }\n        }\n        else {\n            msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n        }\n        return msg;\n    }\n}\n","/**\n * SIP Response Reasons\n * DOC: http://www.iana.org/assignments/sip-parameters\n * @internal\n */\nconst REASON_PHRASE = {\n    100: \"Trying\",\n    180: \"Ringing\",\n    181: \"Call Is Being Forwarded\",\n    182: \"Queued\",\n    183: \"Session Progress\",\n    199: \"Early Dialog Terminated\",\n    200: \"OK\",\n    202: \"Accepted\",\n    204: \"No Notification\",\n    300: \"Multiple Choices\",\n    301: \"Moved Permanently\",\n    302: \"Moved Temporarily\",\n    305: \"Use Proxy\",\n    380: \"Alternative Service\",\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    402: \"Payment Required\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    405: \"Method Not Allowed\",\n    406: \"Not Acceptable\",\n    407: \"Proxy Authentication Required\",\n    408: \"Request Timeout\",\n    410: \"Gone\",\n    412: \"Conditional Request Failed\",\n    413: \"Request Entity Too Large\",\n    414: \"Request-URI Too Long\",\n    415: \"Unsupported Media Type\",\n    416: \"Unsupported URI Scheme\",\n    417: \"Unknown Resource-Priority\",\n    420: \"Bad Extension\",\n    421: \"Extension Required\",\n    422: \"Session Interval Too Small\",\n    423: \"Interval Too Brief\",\n    428: \"Use Identity Header\",\n    429: \"Provide Referrer Identity\",\n    430: \"Flow Failed\",\n    433: \"Anonymity Disallowed\",\n    436: \"Bad Identity-Info\",\n    437: \"Unsupported Certificate\",\n    438: \"Invalid Identity Header\",\n    439: \"First Hop Lacks Outbound Support\",\n    440: \"Max-Breadth Exceeded\",\n    469: \"Bad Info Package\",\n    470: \"Consent Needed\",\n    478: \"Unresolvable Destination\",\n    480: \"Temporarily Unavailable\",\n    481: \"Call/Transaction Does Not Exist\",\n    482: \"Loop Detected\",\n    483: \"Too Many Hops\",\n    484: \"Address Incomplete\",\n    485: \"Ambiguous\",\n    486: \"Busy Here\",\n    487: \"Request Terminated\",\n    488: \"Not Acceptable Here\",\n    489: \"Bad Event\",\n    491: \"Request Pending\",\n    493: \"Undecipherable\",\n    494: \"Security Agreement Required\",\n    500: \"Internal Server Error\",\n    501: \"Not Implemented\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    504: \"Server Time-out\",\n    505: \"Version Not Supported\",\n    513: \"Message Too Large\",\n    580: \"Precondition Failure\",\n    600: \"Busy Everywhere\",\n    603: \"Decline\",\n    604: \"Does Not Exist Anywhere\",\n    606: \"Not Acceptable\"\n};\n/**\n * @param size -\n * @param base -\n * @internal\n */\nexport function createRandomToken(size, base = 32) {\n    let token = \"\";\n    for (let i = 0; i < size; i++) {\n        const r = Math.floor(Math.random() * base);\n        token += r.toString(base);\n    }\n    return token;\n}\n/**\n * @internal\n */\nexport function getReasonPhrase(code) {\n    return REASON_PHRASE[code] || \"\";\n}\n/**\n * @internal\n */\nexport function newTag() {\n    return createRandomToken(10);\n}\n/**\n * @param str -\n * @internal\n */\nexport function headerize(str) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const exceptions = {\n        \"Call-Id\": \"Call-ID\",\n        Cseq: \"CSeq\",\n        \"Min-Se\": \"Min-SE\",\n        Rack: \"RAck\",\n        Rseq: \"RSeq\",\n        \"Www-Authenticate\": \"WWW-Authenticate\"\n    };\n    const name = str.toLowerCase().replace(/_/g, \"-\").split(\"-\");\n    const parts = name.length;\n    let hname = \"\";\n    for (let part = 0; part < parts; part++) {\n        if (part !== 0) {\n            hname += \"-\";\n        }\n        hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);\n    }\n    if (exceptions[hname]) {\n        hname = exceptions[hname];\n    }\n    return hname;\n}\n/**\n * @param str -\n * @internal\n */\nexport function utf8Length(str) {\n    return encodeURIComponent(str).replace(/%[A-F\\d]{2}/g, \"U\").length;\n}\n","/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable no-inner-declarations */\nimport * as pegGrammar from \"./pegjs/dist/grammar.js\";\n/**\n * Grammar.\n * @internal\n */\nexport var Grammar;\n(function (Grammar) {\n    /**\n     * Parse.\n     * @param input -\n     * @param startRule -\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function parse(input, startRule) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const options = { startRule };\n        try {\n            pegGrammar.parse(input, options);\n        }\n        catch (e) {\n            options.data = -1;\n        }\n        return options.data;\n    }\n    Grammar.parse = parse;\n    /**\n     * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if\n     * it is an invalid NameAddrHeader.\n     * @param name_addr_header -\n     */\n    function nameAddrHeaderParse(nameAddrHeader) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parsedNameAddrHeader = Grammar.parse(nameAddrHeader, \"Name_Addr_Header\");\n        return parsedNameAddrHeader !== -1 ? parsedNameAddrHeader : undefined;\n    }\n    Grammar.nameAddrHeaderParse = nameAddrHeaderParse;\n    /**\n     * Parse the given string and returns a SIP.URI instance or undefined if\n     * it is an invalid URI.\n     * @param uri -\n     */\n    function URIParse(uri) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parsedUri = Grammar.parse(uri, \"SIP_URI\");\n        return parsedUri !== -1 ? parsedUri : undefined;\n    }\n    Grammar.URIParse = URIParse;\n})(Grammar = Grammar || (Grammar = {}));\n","import { Parameters } from \"./parameters.js\";\n/**\n * Name Address SIP header.\n * @public\n */\nexport class NameAddrHeader extends Parameters {\n    /**\n     * Constructor\n     * @param uri -\n     * @param displayName -\n     * @param parameters -\n     */\n    constructor(uri, displayName, parameters) {\n        super(parameters);\n        this.uri = uri;\n        this._displayName = displayName;\n    }\n    get friendlyName() {\n        return this.displayName || this.uri.aor;\n    }\n    get displayName() { return this._displayName; }\n    set displayName(value) {\n        this._displayName = value;\n    }\n    clone() {\n        return new NameAddrHeader(this.uri.clone(), this._displayName, JSON.parse(JSON.stringify(this.parameters)));\n    }\n    toString() {\n        let body = (this.displayName || this.displayName === \"0\") ? '\"' + this.displayName + '\" ' : \"\";\n        body += \"<\" + this.uri.toString() + \">\";\n        for (const parameter in this.parameters) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (this.parameters.hasOwnProperty(parameter)) {\n                body += \";\" + parameter;\n                if (this.parameters[parameter] !== null) {\n                    body += \"=\" + this.parameters[parameter];\n                }\n            }\n        }\n        return body;\n    }\n}\n","/**\n * @internal\n */\nexport class Parameters {\n    constructor(parameters) {\n        this.parameters = {};\n        // for in is required here as the Grammar parser is adding to the prototype chain\n        for (const param in parameters) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (parameters.hasOwnProperty(param)) {\n                this.setParam(param, parameters[param]);\n            }\n        }\n    }\n    setParam(key, value) {\n        if (key) {\n            this.parameters[key.toLowerCase()] = (typeof value === \"undefined\" || value === null) ? null : value.toString();\n        }\n    }\n    getParam(key) {\n        if (key) {\n            return this.parameters[key.toLowerCase()];\n        }\n    }\n    hasParam(key) {\n        return !!(key && this.parameters[key.toLowerCase()] !== undefined);\n    }\n    deleteParam(key) {\n        key = key.toLowerCase();\n        if (this.hasParam(key)) {\n            const value = this.parameters[key];\n            delete this.parameters[key];\n            return value;\n        }\n    }\n    clearParams() {\n        this.parameters = {};\n    }\n}\n","import { NameAddrHeader } from \"../../name-addr-header.js\";\nimport { URI } from \"../../uri.js\";\nfunction peg$padEnd(str, targetLength, padString) {\n    padString = padString || ' ';\n    if (str.length > targetLength) {\n        return str;\n    }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n}\nexport class SyntaxError extends Error {\n    constructor(message, expected, found, location) {\n        super();\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n        if (typeof Object.setPrototypeOf === \"function\") {\n            Object.setPrototypeOf(this, SyntaxError.prototype);\n        }\n        else {\n            this.__proto__ = SyntaxError.prototype;\n        }\n        if (typeof Error.captureStackTrace === \"function\") {\n            Error.captureStackTrace(this, SyntaxError);\n        }\n    }\n    static buildMessage(expected, found) {\n        function hex(ch) {\n            return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n        function literalEscape(s) {\n            return s\n                .replace(/\\\\/g, \"\\\\\\\\\")\n                .replace(/\"/g, \"\\\\\\\"\")\n                .replace(/\\0/g, \"\\\\0\")\n                .replace(/\\t/g, \"\\\\t\")\n                .replace(/\\n/g, \"\\\\n\")\n                .replace(/\\r/g, \"\\\\r\")\n                .replace(/[\\x00-\\x0F]/g, (ch) => \"\\\\x0\" + hex(ch))\n                .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch) => \"\\\\x\" + hex(ch));\n        }\n        function classEscape(s) {\n            return s\n                .replace(/\\\\/g, \"\\\\\\\\\")\n                .replace(/\\]/g, \"\\\\]\")\n                .replace(/\\^/g, \"\\\\^\")\n                .replace(/-/g, \"\\\\-\")\n                .replace(/\\0/g, \"\\\\0\")\n                .replace(/\\t/g, \"\\\\t\")\n                .replace(/\\n/g, \"\\\\n\")\n                .replace(/\\r/g, \"\\\\r\")\n                .replace(/[\\x00-\\x0F]/g, (ch) => \"\\\\x0\" + hex(ch))\n                .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch) => \"\\\\x\" + hex(ch));\n        }\n        function describeExpectation(expectation) {\n            switch (expectation.type) {\n                case \"literal\":\n                    return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n                case \"class\":\n                    const escapedParts = expectation.parts.map((part) => {\n                        return Array.isArray(part)\n                            ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n                            : classEscape(part);\n                    });\n                    return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n                case \"any\":\n                    return \"any character\";\n                case \"end\":\n                    return \"end of input\";\n                case \"other\":\n                    return expectation.description;\n            }\n        }\n        function describeExpected(expected1) {\n            const descriptions = expected1.map(describeExpectation);\n            let i;\n            let j;\n            descriptions.sort();\n            if (descriptions.length > 0) {\n                for (i = 1, j = 1; i < descriptions.length; i++) {\n                    if (descriptions[i - 1] !== descriptions[i]) {\n                        descriptions[j] = descriptions[i];\n                        j++;\n                    }\n                }\n                descriptions.length = j;\n            }\n            switch (descriptions.length) {\n                case 1:\n                    return descriptions[0];\n                case 2:\n                    return descriptions[0] + \" or \" + descriptions[1];\n                default:\n                    return descriptions.slice(0, -1).join(\", \")\n                        + \", or \"\n                        + descriptions[descriptions.length - 1];\n            }\n        }\n        function describeFound(found1) {\n            return found1 ? \"\\\"\" + literalEscape(found1) + \"\\\"\" : \"end of input\";\n        }\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    }\n    format(sources) {\n        let str = 'Error: ' + this.message;\n        if (this.location) {\n            let src = null;\n            let k;\n            for (k = 0; k < sources.length; k++) {\n                if (sources[k].source === this.location.source) {\n                    src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n                    break;\n                }\n            }\n            let s = this.location.start;\n            let loc = this.location.source + ':' + s.line + ':' + s.column;\n            if (src) {\n                let e = this.location.end;\n                let filler = peg$padEnd('', s.line.toString().length, ' ');\n                let line = src[s.line - 1];\n                let last = s.line === e.line ? e.column : line.length + 1;\n                str += '\\n --> ' + loc + '\\n' + filler + ' |\\n' + s.line + ' | ' + line + '\\n' + filler + ' | ' +\n                    peg$padEnd('', s.column - 1, ' ') +\n                    peg$padEnd('', last - s.column, '^');\n            }\n            else {\n                str += '\\n at ' + loc;\n            }\n        }\n        return str;\n    }\n}\nfunction peg$parse(input, options) {\n    options = options !== undefined ? options : {};\n    const peg$FAILED = {};\n    const peg$source = options.grammarSource;\n    const peg$startRuleIndices = { Contact: 119, Name_Addr_Header: 156, Record_Route: 176, Request_Response: 81, SIP_URI: 45, Subscription_State: 186, Supported: 191, Require: 182, Via: 194, absoluteURI: 84, Call_ID: 118, Content_Disposition: 130, Content_Length: 135, Content_Type: 136, CSeq: 146, displayName: 122, Event: 149, From: 151, host: 52, Max_Forwards: 154, Min_SE: 213, Proxy_Authenticate: 157, quoted_string: 40, Refer_To: 178, Replaces: 179, Session_Expires: 210, stun_URI: 217, To: 192, turn_URI: 223, uuid: 226, WWW_Authenticate: 209, challenge: 158, sipfrag: 230, Referred_By: 231 };\n    let peg$startRuleIndex = 119;\n    const peg$consts = [\n        \"\\r\\n\",\n        peg$literalExpectation(\"\\r\\n\", false),\n        /^[0-9]/,\n        peg$classExpectation([[\"0\", \"9\"]], false, false),\n        /^[a-zA-Z]/,\n        peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false),\n        /^[0-9a-fA-F]/,\n        peg$classExpectation([[\"0\", \"9\"], [\"a\", \"f\"], [\"A\", \"F\"]], false, false),\n        /^[\\0-\\xFF]/,\n        peg$classExpectation([[\"\\0\", \"\\xFF\"]], false, false),\n        /^[\"]/,\n        peg$classExpectation([\"\\\"\"], false, false),\n        \" \",\n        peg$literalExpectation(\" \", false),\n        \"\\t\",\n        peg$literalExpectation(\"\\t\", false),\n        /^[a-zA-Z0-9]/,\n        peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false),\n        \";\",\n        peg$literalExpectation(\";\", false),\n        \"/\",\n        peg$literalExpectation(\"/\", false),\n        \"?\",\n        peg$literalExpectation(\"?\", false),\n        \":\",\n        peg$literalExpectation(\":\", false),\n        \"@\",\n        peg$literalExpectation(\"@\", false),\n        \"&\",\n        peg$literalExpectation(\"&\", false),\n        \"=\",\n        peg$literalExpectation(\"=\", false),\n        \"+\",\n        peg$literalExpectation(\"+\", false),\n        \"$\",\n        peg$literalExpectation(\"$\", false),\n        \",\",\n        peg$literalExpectation(\",\", false),\n        \"-\",\n        peg$literalExpectation(\"-\", false),\n        \"_\",\n        peg$literalExpectation(\"_\", false),\n        \".\",\n        peg$literalExpectation(\".\", false),\n        \"!\",\n        peg$literalExpectation(\"!\", false),\n        \"~\",\n        peg$literalExpectation(\"~\", false),\n        \"*\",\n        peg$literalExpectation(\"*\", false),\n        \"'\",\n        peg$literalExpectation(\"'\", false),\n        \"(\",\n        peg$literalExpectation(\"(\", false),\n        \")\",\n        peg$literalExpectation(\")\", false),\n        \"%\",\n        peg$literalExpectation(\"%\", false),\n        function () { return \" \"; },\n        function () { return ':'; },\n        /^[!-~]/,\n        peg$classExpectation([[\"!\", \"~\"]], false, false),\n        /^[\\x80-\\uFFFF]/,\n        peg$classExpectation([[\"\\x80\", \"\\uFFFF\"]], false, false),\n        /^[\\x80-\\xBF]/,\n        peg$classExpectation([[\"\\x80\", \"\\xBF\"]], false, false),\n        /^[a-f]/,\n        peg$classExpectation([[\"a\", \"f\"]], false, false),\n        \"`\",\n        peg$literalExpectation(\"`\", false),\n        \"<\",\n        peg$literalExpectation(\"<\", false),\n        \">\",\n        peg$literalExpectation(\">\", false),\n        \"\\\\\",\n        peg$literalExpectation(\"\\\\\", false),\n        \"[\",\n        peg$literalExpectation(\"[\", false),\n        \"]\",\n        peg$literalExpectation(\"]\", false),\n        \"{\",\n        peg$literalExpectation(\"{\", false),\n        \"}\",\n        peg$literalExpectation(\"}\", false),\n        function () { return \"*\"; },\n        function () { return \"/\"; },\n        function () { return \"=\"; },\n        function () { return \"(\"; },\n        function () { return \")\"; },\n        function () { return \">\"; },\n        function () { return \"<\"; },\n        function () { return \",\"; },\n        function () { return \";\"; },\n        function () { return \":\"; },\n        function () { return \"\\\"\"; },\n        /^[!-']/,\n        peg$classExpectation([[\"!\", \"'\"]], false, false),\n        /^[*-[]/,\n        peg$classExpectation([[\"*\", \"[\"]], false, false),\n        /^[\\]-~]/,\n        peg$classExpectation([[\"]\", \"~\"]], false, false),\n        function (contents) {\n            return contents;\n        },\n        /^[#-[]/,\n        peg$classExpectation([[\"#\", \"[\"]], false, false),\n        /^[\\0-\\t]/,\n        peg$classExpectation([[\"\\0\", \"\\t\"]], false, false),\n        /^[\\v-\\f]/,\n        peg$classExpectation([[\"\\v\", \"\\f\"]], false, false),\n        /^[\\x0E-\\x7F]/,\n        peg$classExpectation([[\"\\x0E\", \"\\x7F\"]], false, false),\n        function () {\n            options = options || { data: {} };\n            options.data.uri = new URI(options.data.scheme, options.data.user, options.data.host, options.data.port);\n            delete options.data.scheme;\n            delete options.data.user;\n            delete options.data.host;\n            delete options.data.host_type;\n            delete options.data.port;\n        },\n        function () {\n            options = options || { data: {} };\n            options.data.uri = new URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n            delete options.data.scheme;\n            delete options.data.user;\n            delete options.data.host;\n            delete options.data.host_type;\n            delete options.data.port;\n            delete options.data.uri_params;\n            if (options.startRule === 'SIP_URI') {\n                options.data = options.data.uri;\n            }\n        },\n        \"sips\",\n        peg$literalExpectation(\"sips\", true),\n        \"sip\",\n        peg$literalExpectation(\"sip\", true),\n        function (uri_scheme) {\n            options = options || { data: {} };\n            options.data.scheme = uri_scheme;\n        },\n        function () {\n            options = options || { data: {} };\n            options.data.user = decodeURIComponent(text().slice(0, -1));\n        },\n        function () {\n            options = options || { data: {} };\n            options.data.password = text();\n        },\n        function () {\n            options = options || { data: {} };\n            options.data.host = text();\n            return options.data.host;\n        },\n        function () {\n            options = options || { data: {} };\n            options.data.host_type = 'domain';\n            return text();\n        },\n        /^[a-zA-Z0-9_\\-]/,\n        peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"_\", \"-\"], false, false),\n        /^[a-zA-Z0-9\\-]/,\n        peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"-\"], false, false),\n        function () {\n            options = options || { data: {} };\n            options.data.host_type = 'IPv6';\n            return text();\n        },\n        \"::\",\n        peg$literalExpectation(\"::\", false),\n        function () {\n            options = options || { data: {} };\n            options.data.host_type = 'IPv6';\n            return text();\n        },\n        function () {\n            options = options || { data: {} };\n            options.data.host_type = 'IPv4';\n            return text();\n        },\n        \"25\",\n        peg$literalExpectation(\"25\", false),\n        /^[0-5]/,\n        peg$classExpectation([[\"0\", \"5\"]], false, false),\n        \"2\",\n        peg$literalExpectation(\"2\", false),\n        /^[0-4]/,\n        peg$classExpectation([[\"0\", \"4\"]], false, false),\n        \"1\",\n        peg$literalExpectation(\"1\", false),\n        /^[1-9]/,\n        peg$classExpectation([[\"1\", \"9\"]], false, false),\n        function (port) {\n            options = options || { data: {} };\n            port = parseInt(port.join(''));\n            options.data.port = port;\n            return port;\n        },\n        \"transport=\",\n        peg$literalExpectation(\"transport=\", true),\n        \"udp\",\n        peg$literalExpectation(\"udp\", true),\n        \"tcp\",\n        peg$literalExpectation(\"tcp\", true),\n        \"sctp\",\n        peg$literalExpectation(\"sctp\", true),\n        \"tls\",\n        peg$literalExpectation(\"tls\", true),\n        function (transport) {\n            options = options || { data: {} };\n            if (!options.data.uri_params)\n                options.data.uri_params = {};\n            options.data.uri_params['transport'] = transport.toLowerCase();\n        },\n        \"user=\",\n        peg$literalExpectation(\"user=\", true),\n        \"phone\",\n        peg$literalExpectation(\"phone\", true),\n        \"ip\",\n        peg$literalExpectation(\"ip\", true),\n        function (user) {\n            options = options || { data: {} };\n            if (!options.data.uri_params)\n                options.data.uri_params = {};\n            options.data.uri_params['user'] = user.toLowerCase();\n        },\n        \"method=\",\n        peg$literalExpectation(\"method=\", true),\n        function (method) {\n            options = options || { data: {} };\n            if (!options.data.uri_params)\n                options.data.uri_params = {};\n            options.data.uri_params['method'] = method;\n        },\n        \"ttl=\",\n        peg$literalExpectation(\"ttl=\", true),\n        function (ttl) {\n            options = options || { data: {} };\n            if (!options.data.params)\n                options.data.params = {};\n            options.data.params['ttl'] = ttl;\n        },\n        \"maddr=\",\n        peg$literalExpectation(\"maddr=\", true),\n        function (maddr) {\n            options = options || { data: {} };\n            if (!options.data.uri_params)\n                options.data.uri_params = {};\n            options.data.uri_params['maddr'] = maddr;\n        },\n        \"lr\",\n        peg$literalExpectation(\"lr\", true),\n        function () {\n            options = options || { data: {} };\n            if (!options.data.uri_params)\n                options.data.uri_params = {};\n            options.data.uri_params['lr'] = undefined;\n        },\n        function (param, value) {\n            options = options || { data: {} };\n            if (!options.data.uri_params)\n                options.data.uri_params = {};\n            if (value === null) {\n                value = undefined;\n            }\n            else {\n                value = value[1];\n            }\n            options.data.uri_params[param.toLowerCase()] = value;\n        },\n        function (hname, hvalue) {\n            hname = hname.join('').toLowerCase();\n            hvalue = hvalue.join('');\n            options = options || { data: {} };\n            if (!options.data.uri_headers)\n                options.data.uri_headers = {};\n            if (!options.data.uri_headers[hname]) {\n                options.data.uri_headers[hname] = [hvalue];\n            }\n            else {\n                options.data.uri_headers[hname].push(hvalue);\n            }\n        },\n        function () {\n            options = options || { data: {} };\n            // lots of tests fail if this isn't guarded...\n            if (options.startRule === 'Refer_To') {\n                options.data.uri = new URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n                delete options.data.scheme;\n                delete options.data.user;\n                delete options.data.host;\n                delete options.data.host_type;\n                delete options.data.port;\n                delete options.data.uri_params;\n            }\n        },\n        \"//\",\n        peg$literalExpectation(\"//\", false),\n        function () {\n            options = options || { data: {} };\n            options.data.scheme = text();\n        },\n        peg$literalExpectation(\"SIP\", true),\n        function () {\n            options = options || { data: {} };\n            options.data.sip_version = text();\n        },\n        \"INVITE\",\n        peg$literalExpectation(\"INVITE\", false),\n        \"ACK\",\n        peg$literalExpectation(\"ACK\", false),\n        \"VXACH\",\n        peg$literalExpectation(\"VXACH\", false),\n        \"OPTIONS\",\n        peg$literalExpectation(\"OPTIONS\", false),\n        \"BYE\",\n        peg$literalExpectation(\"BYE\", false),\n        \"CANCEL\",\n        peg$literalExpectation(\"CANCEL\", false),\n        \"REGISTER\",\n        peg$literalExpectation(\"REGISTER\", false),\n        \"SUBSCRIBE\",\n        peg$literalExpectation(\"SUBSCRIBE\", false),\n        \"NOTIFY\",\n        peg$literalExpectation(\"NOTIFY\", false),\n        \"REFER\",\n        peg$literalExpectation(\"REFER\", false),\n        \"PUBLISH\",\n        peg$literalExpectation(\"PUBLISH\", false),\n        function () {\n            options = options || { data: {} };\n            options.data.method = text();\n            return options.data.method;\n        },\n        function (status_code) {\n            options = options || { data: {} };\n            options.data.status_code = parseInt(status_code.join(''));\n        },\n        function () {\n            options = options || { data: {} };\n            options.data.reason_phrase = text();\n        },\n        function () {\n            options = options || { data: {} };\n            options.data = text();\n        },\n        function () {\n            var idx, length;\n            options = options || { data: {} };\n            length = options.data.multi_header.length;\n            for (idx = 0; idx < length; idx++) {\n                if (options.data.multi_header[idx].parsed === null) {\n                    options.data = null;\n                    break;\n                }\n            }\n            if (options.data !== null) {\n                options.data = options.data.multi_header;\n            }\n            else {\n                options.data = -1;\n            }\n        },\n        function () {\n            var header;\n            options = options || { data: {} };\n            if (!options.data.multi_header)\n                options.data.multi_header = [];\n            try {\n                header = new NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n                delete options.data.uri;\n                delete options.data.displayName;\n                delete options.data.params;\n            }\n            catch (e) {\n                header = null;\n            }\n            options.data.multi_header.push({ 'position': peg$currPos,\n                'offset': location().start.offset,\n                'parsed': header\n            });\n        },\n        function (displayName) {\n            displayName = text().trim();\n            if (displayName[0] === '\\\"') {\n                displayName = displayName.substring(1, displayName.length - 1);\n            }\n            options = options || { data: {} };\n            options.data.displayName = displayName;\n        },\n        \"q\",\n        peg$literalExpectation(\"q\", true),\n        function (q) {\n            options = options || { data: {} };\n            if (!options.data.params)\n                options.data.params = {};\n            options.data.params['q'] = q;\n        },\n        \"expires\",\n        peg$literalExpectation(\"expires\", true),\n        function (expires) {\n            options = options || { data: {} };\n            if (!options.data.params)\n                options.data.params = {};\n            options.data.params['expires'] = expires;\n        },\n        function (delta_seconds) {\n            return parseInt(delta_seconds.join(''));\n        },\n        \"0\",\n        peg$literalExpectation(\"0\", false),\n        function () {\n            return parseFloat(text());\n        },\n        function (param, value) {\n            options = options || { data: {} };\n            if (!options.data.params)\n                options.data.params = {};\n            if (value === null) {\n                value = undefined;\n            }\n            else {\n                value = value[1];\n            }\n            options.data.params[param.toLowerCase()] = value;\n        },\n        \"render\",\n        peg$literalExpectation(\"render\", true),\n        \"session\",\n        peg$literalExpectation(\"session\", true),\n        \"icon\",\n        peg$literalExpectation(\"icon\", true),\n        \"alert\",\n        peg$literalExpectation(\"alert\", true),\n        function () {\n            options = options || { data: {} };\n            if (options.startRule === 'Content_Disposition') {\n                options.data.type = text().toLowerCase();\n            }\n        },\n        \"handling\",\n        peg$literalExpectation(\"handling\", true),\n        \"optional\",\n        peg$literalExpectation(\"optional\", true),\n        \"required\",\n        peg$literalExpectation(\"required\", true),\n        function (length) {\n            options = options || { data: {} };\n            options.data = parseInt(length.join(''));\n        },\n        function () {\n            options = options || { data: {} };\n            options.data = text();\n        },\n        \"text\",\n        peg$literalExpectation(\"text\", true),\n        \"image\",\n        peg$literalExpectation(\"image\", true),\n        \"audio\",\n        peg$literalExpectation(\"audio\", true),\n        \"video\",\n        peg$literalExpectation(\"video\", true),\n        \"application\",\n        peg$literalExpectation(\"application\", true),\n        \"message\",\n        peg$literalExpectation(\"message\", true),\n        \"multipart\",\n        peg$literalExpectation(\"multipart\", true),\n        \"x-\",\n        peg$literalExpectation(\"x-\", true),\n        function (cseq_value) {\n            options = options || { data: {} };\n            options.data.value = parseInt(cseq_value.join(''));\n        },\n        function (expires) { options = options || { data: {} }; options.data = expires; },\n        function (event_type) {\n            options = options || { data: {} };\n            options.data.event = event_type.toLowerCase();\n        },\n        function () {\n            options = options || { data: {} };\n            var tag = options.data.tag;\n            options.data = new NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n            if (tag) {\n                options.data.setParam('tag', tag);\n            }\n        },\n        \"tag\",\n        peg$literalExpectation(\"tag\", true),\n        function (tag) { options = options || { data: {} }; options.data.tag = tag; },\n        function (forwards) {\n            options = options || { data: {} };\n            options.data = parseInt(forwards.join(''));\n        },\n        function (min_expires) { options = options || { data: {} }; options.data = min_expires; },\n        function () {\n            options = options || { data: {} };\n            options.data = new NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n        },\n        \"digest\",\n        peg$literalExpectation(\"Digest\", true),\n        \"realm\",\n        peg$literalExpectation(\"realm\", true),\n        function (realm) { options = options || { data: {} }; options.data.realm = realm; },\n        \"domain\",\n        peg$literalExpectation(\"domain\", true),\n        \"nonce\",\n        peg$literalExpectation(\"nonce\", true),\n        function (nonce) { options = options || { data: {} }; options.data.nonce = nonce; },\n        \"opaque\",\n        peg$literalExpectation(\"opaque\", true),\n        function (opaque) { options = options || { data: {} }; options.data.opaque = opaque; },\n        \"stale\",\n        peg$literalExpectation(\"stale\", true),\n        \"true\",\n        peg$literalExpectation(\"true\", true),\n        function () { options = options || { data: {} }; options.data.stale = true; },\n        \"false\",\n        peg$literalExpectation(\"false\", true),\n        function () { options = options || { data: {} }; options.data.stale = false; },\n        \"algorithm\",\n        peg$literalExpectation(\"algorithm\", true),\n        \"md5\",\n        peg$literalExpectation(\"MD5\", true),\n        \"md5-sess\",\n        peg$literalExpectation(\"MD5-sess\", true),\n        function (algorithm) {\n            options = options || { data: {} };\n            options.data.algorithm = algorithm.toUpperCase();\n        },\n        \"qop\",\n        peg$literalExpectation(\"qop\", true),\n        \"auth-int\",\n        peg$literalExpectation(\"auth-int\", true),\n        \"auth\",\n        peg$literalExpectation(\"auth\", true),\n        function (qop_value) {\n            options = options || { data: {} };\n            options.data.qop || (options.data.qop = []);\n            options.data.qop.push(qop_value.toLowerCase());\n        },\n        function (rack_value) {\n            options = options || { data: {} };\n            options.data.value = parseInt(rack_value.join(''));\n        },\n        function () {\n            var idx, length;\n            options = options || { data: {} };\n            length = options.data.multi_header.length;\n            for (idx = 0; idx < length; idx++) {\n                if (options.data.multi_header[idx].parsed === null) {\n                    options.data = null;\n                    break;\n                }\n            }\n            if (options.data !== null) {\n                options.data = options.data.multi_header;\n            }\n            else {\n                options.data = -1;\n            }\n        },\n        function () {\n            var header;\n            options = options || { data: {} };\n            if (!options.data.multi_header)\n                options.data.multi_header = [];\n            try {\n                header = new NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n                delete options.data.uri;\n                delete options.data.displayName;\n                delete options.data.params;\n            }\n            catch (e) {\n                header = null;\n            }\n            options.data.multi_header.push({ 'position': peg$currPos,\n                'offset': location().start.offset,\n                'parsed': header\n            });\n        },\n        function () {\n            options = options || { data: {} };\n            options.data = new NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n        },\n        function () {\n            options = options || { data: {} };\n            if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {\n                options.data = -1;\n            }\n        },\n        function () {\n            options = options || { data: {} };\n            options.data = {\n                call_id: options.data\n            };\n        },\n        \"from-tag\",\n        peg$literalExpectation(\"from-tag\", true),\n        function (from_tag) {\n            options = options || { data: {} };\n            options.data.replaces_from_tag = from_tag;\n        },\n        \"to-tag\",\n        peg$literalExpectation(\"to-tag\", true),\n        function (to_tag) {\n            options = options || { data: {} };\n            options.data.replaces_to_tag = to_tag;\n        },\n        \"early-only\",\n        peg$literalExpectation(\"early-only\", true),\n        function () {\n            options = options || { data: {} };\n            options.data.early_only = true;\n        },\n        function (head, r) { return r; },\n        function (head, tail) { return list(head, tail); },\n        function (value) {\n            options = options || { data: {} };\n            if (options.startRule === 'Require') {\n                options.data = value || [];\n            }\n        },\n        function (rseq_value) {\n            options = options || { data: {} };\n            options.data.value = parseInt(rseq_value.join(''));\n        },\n        \"active\",\n        peg$literalExpectation(\"active\", true),\n        \"pending\",\n        peg$literalExpectation(\"pending\", true),\n        \"terminated\",\n        peg$literalExpectation(\"terminated\", true),\n        function () {\n            options = options || { data: {} };\n            options.data.state = text();\n        },\n        \"reason\",\n        peg$literalExpectation(\"reason\", true),\n        function (reason) {\n            options = options || { data: {} };\n            if (typeof reason !== 'undefined')\n                options.data.reason = reason;\n        },\n        function (expires) {\n            options = options || { data: {} };\n            if (typeof expires !== 'undefined')\n                options.data.expires = expires;\n        },\n        \"retry_after\",\n        peg$literalExpectation(\"retry_after\", true),\n        function (retry_after) {\n            options = options || { data: {} };\n            if (typeof retry_after !== 'undefined')\n                options.data.retry_after = retry_after;\n        },\n        \"deactivated\",\n        peg$literalExpectation(\"deactivated\", true),\n        \"probation\",\n        peg$literalExpectation(\"probation\", true),\n        \"rejected\",\n        peg$literalExpectation(\"rejected\", true),\n        \"timeout\",\n        peg$literalExpectation(\"timeout\", true),\n        \"giveup\",\n        peg$literalExpectation(\"giveup\", true),\n        \"noresource\",\n        peg$literalExpectation(\"noresource\", true),\n        \"invariant\",\n        peg$literalExpectation(\"invariant\", true),\n        function (value) {\n            options = options || { data: {} };\n            if (options.startRule === 'Supported') {\n                options.data = value || [];\n            }\n        },\n        function () {\n            options = options || { data: {} };\n            var tag = options.data.tag;\n            options.data = new NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n            if (tag) {\n                options.data.setParam('tag', tag);\n            }\n        },\n        \"ttl\",\n        peg$literalExpectation(\"ttl\", true),\n        function (via_ttl_value) {\n            options = options || { data: {} };\n            options.data.ttl = via_ttl_value;\n        },\n        \"maddr\",\n        peg$literalExpectation(\"maddr\", true),\n        function (via_maddr) {\n            options = options || { data: {} };\n            options.data.maddr = via_maddr;\n        },\n        \"received\",\n        peg$literalExpectation(\"received\", true),\n        function (via_received) {\n            options = options || { data: {} };\n            options.data.received = via_received;\n        },\n        \"branch\",\n        peg$literalExpectation(\"branch\", true),\n        function (via_branch) {\n            options = options || { data: {} };\n            options.data.branch = via_branch;\n        },\n        \"rport\",\n        peg$literalExpectation(\"rport\", true),\n        function (response_port) {\n            options = options || { data: {} };\n            if (typeof response_port !== 'undefined')\n                options.data.rport = response_port.join('');\n        },\n        function (via_protocol) {\n            options = options || { data: {} };\n            options.data.protocol = via_protocol;\n        },\n        peg$literalExpectation(\"UDP\", true),\n        peg$literalExpectation(\"TCP\", true),\n        peg$literalExpectation(\"TLS\", true),\n        peg$literalExpectation(\"SCTP\", true),\n        function (via_transport) {\n            options = options || { data: {} };\n            options.data.transport = via_transport;\n        },\n        function () {\n            options = options || { data: {} };\n            options.data.host = text();\n        },\n        function (via_sent_by_port) {\n            options = options || { data: {} };\n            options.data.port = parseInt(via_sent_by_port.join(''));\n        },\n        function (ttl) {\n            return parseInt(ttl.join(''));\n        },\n        function (deltaSeconds) {\n            options = options || { data: {} };\n            if (options.startRule === 'Session_Expires') {\n                options.data.deltaSeconds = deltaSeconds;\n            }\n        },\n        \"refresher\",\n        peg$literalExpectation(\"refresher\", false),\n        \"uas\",\n        peg$literalExpectation(\"uas\", false),\n        \"uac\",\n        peg$literalExpectation(\"uac\", false),\n        function (endpoint) {\n            options = options || { data: {} };\n            if (options.startRule === 'Session_Expires') {\n                options.data.refresher = endpoint;\n            }\n        },\n        function (deltaSeconds) {\n            options = options || { data: {} };\n            if (options.startRule === 'Min_SE') {\n                options.data = deltaSeconds;\n            }\n        },\n        \"stuns\",\n        peg$literalExpectation(\"stuns\", true),\n        \"stun\",\n        peg$literalExpectation(\"stun\", true),\n        function (scheme) {\n            options = options || { data: {} };\n            options.data.scheme = scheme;\n        },\n        function (host) {\n            options = options || { data: {} };\n            options.data.host = host;\n        },\n        \"?transport=\",\n        peg$literalExpectation(\"?transport=\", false),\n        \"turns\",\n        peg$literalExpectation(\"turns\", true),\n        \"turn\",\n        peg$literalExpectation(\"turn\", true),\n        function (transport) {\n            options = options || { data: {} };\n            options.data.transport = transport;\n        },\n        function () {\n            options = options || { data: {} };\n            options.data = text();\n        },\n        \"Referred-By\",\n        peg$literalExpectation(\"Referred-By\", false),\n        \"b\",\n        peg$literalExpectation(\"b\", false),\n        \"cid\",\n        peg$literalExpectation(\"cid\", false)\n    ];\n    const peg$bytecode = [\n        peg$decode(\"2 \\\"\\\"6 7!\"),\n        peg$decode(\"4\\\"\\\"\\\"5!7#\"),\n        peg$decode(\"4$\\\"\\\"5!7%\"),\n        peg$decode(\"4&\\\"\\\"5!7'\"),\n        peg$decode(\";'.# &;(\"),\n        peg$decode(\"4(\\\"\\\"5!7)\"),\n        peg$decode(\"4*\\\"\\\"5!7+\"),\n        peg$decode(\"2,\\\"\\\"6,7-\"),\n        peg$decode(\"2.\\\"\\\"6.7/\"),\n        peg$decode(\"40\\\"\\\"5!71\"),\n        peg$decode(\"22\\\"\\\"6273.\\x89 &24\\\"\\\"6475.} &26\\\"\\\"6677.q &28\\\"\\\"6879.e &2:\\\"\\\"6:7;.Y &2<\\\"\\\"6<7=.M &2>\\\"\\\"6>7?.A &2@\\\"\\\"6@7A.5 &2B\\\"\\\"6B7C.) &2D\\\"\\\"6D7E\"),\n        peg$decode(\";).# &;,\"),\n        peg$decode(\"2F\\\"\\\"6F7G.} &2H\\\"\\\"6H7I.q &2J\\\"\\\"6J7K.e &2L\\\"\\\"6L7M.Y &2N\\\"\\\"6N7O.M &2P\\\"\\\"6P7Q.A &2R\\\"\\\"6R7S.5 &2T\\\"\\\"6T7U.) &2V\\\"\\\"6V7W\"),\n        peg$decode(\"%%2X\\\"\\\"6X7Y/5#;#/,$;#/#$+#)(#'#(\\\"'#&'#/\\\"!&,)\"),\n        peg$decode(\"%%$;$0#*;$&/,#; /#$+\\\")(\\\"'#&'#.\\\" &\\\"/=#$;$/&#0#*;$&&&#/'$8\\\":Z\\\" )(\\\"'#&'#\"),\n        peg$decode(\";..\\\" &\\\"\"),\n        peg$decode(\"%$;'.# &;(0)*;'.# &;(&/?#28\\\"\\\"6879/0$;//'$8#:[# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%%$;2/&#0#*;2&&&#/g#$%$;.0#*;.&/,#;2/#$+\\\")(\\\"'#&'#0=*%$;.0#*;.&/,#;2/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#/\\\"!&,)\"),\n        peg$decode(\"4\\\\\\\"\\\"5!7].# &;3\"),\n        peg$decode(\"4^\\\"\\\"5!7_\"),\n        peg$decode(\"4`\\\"\\\"5!7a\"),\n        peg$decode(\";!.) &4b\\\"\\\"5!7c\"),\n        peg$decode(\"%$;).\\x95 &2F\\\"\\\"6F7G.\\x89 &2J\\\"\\\"6J7K.} &2L\\\"\\\"6L7M.q &2X\\\"\\\"6X7Y.e &2P\\\"\\\"6P7Q.Y &2H\\\"\\\"6H7I.M &2@\\\"\\\"6@7A.A &2d\\\"\\\"6d7e.5 &2R\\\"\\\"6R7S.) &2N\\\"\\\"6N7O/\\x9E#0\\x9B*;).\\x95 &2F\\\"\\\"6F7G.\\x89 &2J\\\"\\\"6J7K.} &2L\\\"\\\"6L7M.q &2X\\\"\\\"6X7Y.e &2P\\\"\\\"6P7Q.Y &2H\\\"\\\"6H7I.M &2@\\\"\\\"6@7A.A &2d\\\"\\\"6d7e.5 &2R\\\"\\\"6R7S.) &2N\\\"\\\"6N7O&&&#/\\\"!&,)\"),\n        peg$decode(\"%$;).\\x89 &2F\\\"\\\"6F7G.} &2L\\\"\\\"6L7M.q &2X\\\"\\\"6X7Y.e &2P\\\"\\\"6P7Q.Y &2H\\\"\\\"6H7I.M &2@\\\"\\\"6@7A.A &2d\\\"\\\"6d7e.5 &2R\\\"\\\"6R7S.) &2N\\\"\\\"6N7O/\\x92#0\\x8F*;).\\x89 &2F\\\"\\\"6F7G.} &2L\\\"\\\"6L7M.q &2X\\\"\\\"6X7Y.e &2P\\\"\\\"6P7Q.Y &2H\\\"\\\"6H7I.M &2@\\\"\\\"6@7A.A &2d\\\"\\\"6d7e.5 &2R\\\"\\\"6R7S.) &2N\\\"\\\"6N7O&&&#/\\\"!&,)\"),\n        peg$decode(\"2T\\\"\\\"6T7U.\\xE3 &2V\\\"\\\"6V7W.\\xD7 &2f\\\"\\\"6f7g.\\xCB &2h\\\"\\\"6h7i.\\xBF &2:\\\"\\\"6:7;.\\xB3 &2D\\\"\\\"6D7E.\\xA7 &22\\\"\\\"6273.\\x9B &28\\\"\\\"6879.\\x8F &2j\\\"\\\"6j7k.\\x83 &;&.} &24\\\"\\\"6475.q &2l\\\"\\\"6l7m.e &2n\\\"\\\"6n7o.Y &26\\\"\\\"6677.M &2>\\\"\\\"6>7?.A &2p\\\"\\\"6p7q.5 &2r\\\"\\\"6r7s.) &;'.# &;(\"),\n        peg$decode(\"%$;).\\u012B &2F\\\"\\\"6F7G.\\u011F &2J\\\"\\\"6J7K.\\u0113 &2L\\\"\\\"6L7M.\\u0107 &2X\\\"\\\"6X7Y.\\xFB &2P\\\"\\\"6P7Q.\\xEF &2H\\\"\\\"6H7I.\\xE3 &2@\\\"\\\"6@7A.\\xD7 &2d\\\"\\\"6d7e.\\xCB &2R\\\"\\\"6R7S.\\xBF &2N\\\"\\\"6N7O.\\xB3 &2T\\\"\\\"6T7U.\\xA7 &2V\\\"\\\"6V7W.\\x9B &2f\\\"\\\"6f7g.\\x8F &2h\\\"\\\"6h7i.\\x83 &28\\\"\\\"6879.w &2j\\\"\\\"6j7k.k &;&.e &24\\\"\\\"6475.Y &2l\\\"\\\"6l7m.M &2n\\\"\\\"6n7o.A &26\\\"\\\"6677.5 &2p\\\"\\\"6p7q.) &2r\\\"\\\"6r7s/\\u0134#0\\u0131*;).\\u012B &2F\\\"\\\"6F7G.\\u011F &2J\\\"\\\"6J7K.\\u0113 &2L\\\"\\\"6L7M.\\u0107 &2X\\\"\\\"6X7Y.\\xFB &2P\\\"\\\"6P7Q.\\xEF &2H\\\"\\\"6H7I.\\xE3 &2@\\\"\\\"6@7A.\\xD7 &2d\\\"\\\"6d7e.\\xCB &2R\\\"\\\"6R7S.\\xBF &2N\\\"\\\"6N7O.\\xB3 &2T\\\"\\\"6T7U.\\xA7 &2V\\\"\\\"6V7W.\\x9B &2f\\\"\\\"6f7g.\\x8F &2h\\\"\\\"6h7i.\\x83 &28\\\"\\\"6879.w &2j\\\"\\\"6j7k.k &;&.e &24\\\"\\\"6475.Y &2l\\\"\\\"6l7m.M &2n\\\"\\\"6n7o.A &26\\\"\\\"6677.5 &2p\\\"\\\"6p7q.) &2r\\\"\\\"6r7s&&&#/\\\"!&,)\"),\n        peg$decode(\"%;//?#2P\\\"\\\"6P7Q/0$;//'$8#:t# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#24\\\"\\\"6475/0$;//'$8#:u# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#2>\\\"\\\"6>7?/0$;//'$8#:v# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#2T\\\"\\\"6T7U/0$;//'$8#:w# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#2V\\\"\\\"6V7W/0$;//'$8#:x# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%2h\\\"\\\"6h7i/0#;//'$8\\\":y\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;//6#2f\\\"\\\"6f7g/'$8\\\":z\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;//?#2D\\\"\\\"6D7E/0$;//'$8#:{# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#22\\\"\\\"6273/0$;//'$8#:|# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#28\\\"\\\"6879/0$;//'$8#:}# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//0#;&/'$8\\\":~\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;&/0#;//'$8\\\":~\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;=/T#$;G.) &;K.# &;F0/*;G.) &;K.# &;F&/,$;>/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"4\\x7F\\\"\\\"5!7\\x80.A &4\\x81\\\"\\\"5!7\\x82.5 &4\\x83\\\"\\\"5!7\\x84.) &;3.# &;.\"),\n        peg$decode(\"%%;//Q#;&/H$$;J.# &;K0)*;J.# &;K&/,$;&/#$+$)($'#(#'#(\\\"'#&'#/\\\"!&,)\"),\n        peg$decode(\"%;//]#;&/T$%$;J.# &;K0)*;J.# &;K&/\\\"!&,)/1$;&/($8$:\\x85$!!)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";..G &2L\\\"\\\"6L7M.; &4\\x86\\\"\\\"5!7\\x87./ &4\\x83\\\"\\\"5!7\\x84.# &;3\"),\n        peg$decode(\"%2j\\\"\\\"6j7k/J#4\\x88\\\"\\\"5!7\\x89.5 &4\\x8A\\\"\\\"5!7\\x8B.) &4\\x8C\\\"\\\"5!7\\x8D/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;N/M#28\\\"\\\"6879/>$;O.\\\" &\\\"/0$;S/'$8$:\\x8E$ )($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;N/d#28\\\"\\\"6879/U$;O.\\\" &\\\"/G$;S/>$;_/5$;l.\\\" &\\\"/'$8&:\\x8F& )(&'#(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\x90\\\"\\\"5$7\\x91.) &3\\x92\\\"\\\"5#7\\x93/' 8!:\\x94!! )\"),\n        peg$decode(\"%;P/]#%28\\\"\\\"6879/,#;R/#$+\\\")(\\\"'#&'#.\\\" &\\\"/6$2:\\\"\\\"6:7;/'$8#:\\x95# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"$;+.) &;-.# &;Q/2#0/*;+.) &;-.# &;Q&&&#\"),\n        peg$decode(\"2<\\\"\\\"6<7=.q &2>\\\"\\\"6>7?.e &2@\\\"\\\"6@7A.Y &2B\\\"\\\"6B7C.M &2D\\\"\\\"6D7E.A &22\\\"\\\"6273.5 &26\\\"\\\"6677.) &24\\\"\\\"6475\"),\n        peg$decode(\"%$;+._ &;-.Y &2<\\\"\\\"6<7=.M &2>\\\"\\\"6>7?.A &2@\\\"\\\"6@7A.5 &2B\\\"\\\"6B7C.) &2D\\\"\\\"6D7E0e*;+._ &;-.Y &2<\\\"\\\"6<7=.M &2>\\\"\\\"6>7?.A &2@\\\"\\\"6@7A.5 &2B\\\"\\\"6B7C.) &2D\\\"\\\"6D7E&/& 8!:\\x96! )\"),\n        peg$decode(\"%;T/J#%28\\\"\\\"6879/,#;^/#$+\\\")(\\\"'#&'#.\\\" &\\\"/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;U.) &;\\\\.# &;X/& 8!:\\x97! )\"),\n        peg$decode(\"%$%;V/2#2J\\\"\\\"6J7K/#$+\\\")(\\\"'#&'#0<*%;V/2#2J\\\"\\\"6J7K/#$+\\\")(\\\"'#&'#&/D#;W/;$2J\\\"\\\"6J7K.\\\" &\\\"/'$8#:\\x98# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"$4\\x99\\\"\\\"5!7\\x9A/,#0)*4\\x99\\\"\\\"5!7\\x9A&&&#\"),\n        peg$decode(\"%4$\\\"\\\"5!7%/?#$4\\x9B\\\"\\\"5!7\\x9C0)*4\\x9B\\\"\\\"5!7\\x9C&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%2l\\\"\\\"6l7m/?#;Y/6$2n\\\"\\\"6n7o/'$8#:\\x9D# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%%;Z/\\xB3#28\\\"\\\"6879/\\xA4$;Z/\\x9B$28\\\"\\\"6879/\\x8C$;Z/\\x83$28\\\"\\\"6879/t$;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+-)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u0790 &%2\\x9E\\\"\\\"6\\x9E7\\x9F/\\xA4#;Z/\\x9B$28\\\"\\\"6879/\\x8C$;Z/\\x83$28\\\"\\\"6879/t$;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+,)(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u06F9 &%2\\x9E\\\"\\\"6\\x9E7\\x9F/\\x8C#;Z/\\x83$28\\\"\\\"6879/t$;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u067A &%2\\x9E\\\"\\\"6\\x9E7\\x9F/t#;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u0613 &%2\\x9E\\\"\\\"6\\x9E7\\x9F/\\\\#;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+&)(&'#(%'#($'#(#'#(\\\"'#&'#.\\u05C4 &%2\\x9E\\\"\\\"6\\x9E7\\x9F/D#;Z/;$28\\\"\\\"6879/,$;[/#$+$)($'#(#'#(\\\"'#&'#.\\u058D &%2\\x9E\\\"\\\"6\\x9E7\\x9F/,#;[/#$+\\\")(\\\"'#&'#.\\u056E &%2\\x9E\\\"\\\"6\\x9E7\\x9F/,#;Z/#$+\\\")(\\\"'#&'#.\\u054F &%;Z/\\x9B#2\\x9E\\\"\\\"6\\x9E7\\x9F/\\x8C$;Z/\\x83$28\\\"\\\"6879/t$;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$++)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u04C7 &%;Z/\\xAA#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\x83$2\\x9E\\\"\\\"6\\x9E7\\x9F/t$;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u0430 &%;Z/\\xB9#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\x92$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/k$2\\x9E\\\"\\\"6\\x9E7\\x9F/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+))()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u038A &%;Z/\\xC8#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xA1$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/z$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/S$2\\x9E\\\"\\\"6\\x9E7\\x9F/D$;Z/;$28\\\"\\\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u02D5 &%;Z/\\xD7#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xB0$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\x89$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/b$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/;$2\\x9E\\\"\\\"6\\x9E7\\x9F/,$;[/#$+')(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u0211 &%;Z/\\xFE#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xD7$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xB0$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\x89$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/b$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/;$2\\x9E\\\"\\\"6\\x9E7\\x9F/,$;Z/#$+()(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u0126 &%;Z/\\u011C#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xF5$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xCE$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xA7$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\x80$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/Y$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/2$2\\x9E\\\"\\\"6\\x9E7\\x9F/#$+()(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#/& 8!:\\xA0! )\"),\n        peg$decode(\"%;#/M#;#.\\\" &\\\"/?$;#.\\\" &\\\"/1$;#.\\\" &\\\"/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;Z/;#28\\\"\\\"6879/,$;Z/#$+#)(#'#(\\\"'#&'#.# &;\\\\\"),\n        peg$decode(\"%;]/o#2J\\\"\\\"6J7K/`$;]/W$2J\\\"\\\"6J7K/H$;]/?$2J\\\"\\\"6J7K/0$;]/'$8':\\xA1' )(''#(&'#(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%2\\xA2\\\"\\\"6\\xA27\\xA3/2#4\\xA4\\\"\\\"5!7\\xA5/#$+\\\")(\\\"'#&'#.\\x98 &%2\\xA6\\\"\\\"6\\xA67\\xA7/;#4\\xA8\\\"\\\"5!7\\xA9/,$;!/#$+#)(#'#(\\\"'#&'#.j &%2\\xAA\\\"\\\"6\\xAA7\\xAB/5#;!/,$;!/#$+#)(#'#(\\\"'#&'#.B &%4\\xAC\\\"\\\"5!7\\xAD/,#;!/#$+\\\")(\\\"'#&'#.# &;!\"),\n        peg$decode(\"%%;!.\\\" &\\\"/[#;!.\\\" &\\\"/M$;!.\\\" &\\\"/?$;!.\\\" &\\\"/1$;!.\\\" &\\\"/#$+%)(%'#($'#(#'#(\\\"'#&'#/' 8!:\\xAE!! )\"),\n        peg$decode(\"$%22\\\"\\\"6273/,#;`/#$+\\\")(\\\"'#&'#0<*%22\\\"\\\"6273/,#;`/#$+\\\")(\\\"'#&'#&\"),\n        peg$decode(\";a.A &;b.; &;c.5 &;d./ &;e.) &;f.# &;g\"),\n        peg$decode(\"%3\\xAF\\\"\\\"5*7\\xB0/a#3\\xB1\\\"\\\"5#7\\xB2.G &3\\xB3\\\"\\\"5#7\\xB4.; &3\\xB5\\\"\\\"5$7\\xB6./ &3\\xB7\\\"\\\"5#7\\xB8.# &;6/($8\\\":\\xB9\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%3\\xBA\\\"\\\"5%7\\xBB/I#3\\xBC\\\"\\\"5%7\\xBD./ &3\\xBE\\\"\\\"5\\\"7\\xBF.# &;6/($8\\\":\\xC0\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%3\\xC1\\\"\\\"5'7\\xC2/1#;\\x90/($8\\\":\\xC3\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%3\\xC4\\\"\\\"5$7\\xC5/1#;\\xF0/($8\\\":\\xC6\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%3\\xC7\\\"\\\"5&7\\xC8/1#;T/($8\\\":\\xC9\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%3\\xCA\\\"\\\"5\\\"7\\xCB/N#%2>\\\"\\\"6>7?/,#;6/#$+\\\")(\\\"'#&'#.\\\" &\\\"/'$8\\\":\\xCC\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;h/P#%2>\\\"\\\"6>7?/,#;i/#$+\\\")(\\\"'#&'#.\\\" &\\\"/)$8\\\":\\xCD\\\"\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%$;j/&#0#*;j&&&#/\\\"!&,)\"),\n        peg$decode(\"%$;j/&#0#*;j&&&#/\\\"!&,)\"),\n        peg$decode(\";k.) &;+.# &;-\"),\n        peg$decode(\"2l\\\"\\\"6l7m.e &2n\\\"\\\"6n7o.Y &24\\\"\\\"6475.M &28\\\"\\\"6879.A &2<\\\"\\\"6<7=.5 &2@\\\"\\\"6@7A.) &2B\\\"\\\"6B7C\"),\n        peg$decode(\"%26\\\"\\\"6677/n#;m/e$$%2<\\\"\\\"6<7=/,#;m/#$+\\\")(\\\"'#&'#0<*%2<\\\"\\\"6<7=/,#;m/#$+\\\")(\\\"'#&'#&/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;n/A#2>\\\"\\\"6>7?/2$;o/)$8#:\\xCE#\\\"\\\" )(#'#(\\\"'#&'#\"),\n        peg$decode(\"$;p.) &;+.# &;-/2#0/*;p.) &;+.# &;-&&&#\"),\n        peg$decode(\"$;p.) &;+.# &;-0/*;p.) &;+.# &;-&\"),\n        peg$decode(\"2l\\\"\\\"6l7m.e &2n\\\"\\\"6n7o.Y &24\\\"\\\"6475.M &26\\\"\\\"6677.A &28\\\"\\\"6879.5 &2@\\\"\\\"6@7A.) &2B\\\"\\\"6B7C\"),\n        peg$decode(\";\\x91.# &;r\"),\n        peg$decode(\"%;\\x90/G#;'/>$;s/5$;'/,$;\\x84/#$+%)(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";M.# &;t\"),\n        peg$decode(\"%;\\x7F/E#28\\\"\\\"6879/6$;u.# &;x/'$8#:\\xCF# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;v.# &;w/J#%26\\\"\\\"6677/,#;\\x83/#$+\\\")(\\\"'#&'#.\\\" &\\\"/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%2\\xD0\\\"\\\"6\\xD07\\xD1/:#;\\x80/1$;w.\\\" &\\\"/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%24\\\"\\\"6475/,#;{/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;z/3#$;y0#*;y&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\";*.) &;+.# &;-\"),\n        peg$decode(\";+.\\x8F &;-.\\x89 &22\\\"\\\"6273.} &26\\\"\\\"6677.q &28\\\"\\\"6879.e &2:\\\"\\\"6:7;.Y &2<\\\"\\\"6<7=.M &2>\\\"\\\"6>7?.A &2@\\\"\\\"6@7A.5 &2B\\\"\\\"6B7C.) &2D\\\"\\\"6D7E\"),\n        peg$decode(\"%;|/e#$%24\\\"\\\"6475/,#;|/#$+\\\")(\\\"'#&'#0<*%24\\\"\\\"6475/,#;|/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%$;~0#*;~&/e#$%22\\\"\\\"6273/,#;}/#$+\\\")(\\\"'#&'#0<*%22\\\"\\\"6273/,#;}/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"$;~0#*;~&\"),\n        peg$decode(\";+.w &;-.q &28\\\"\\\"6879.e &2:\\\"\\\"6:7;.Y &2<\\\"\\\"6<7=.M &2>\\\"\\\"6>7?.A &2@\\\"\\\"6@7A.5 &2B\\\"\\\"6B7C.) &2D\\\"\\\"6D7E\"),\n        peg$decode(\"%%;\\\"/\\x87#$;\\\".G &;!.A &2@\\\"\\\"6@7A.5 &2F\\\"\\\"6F7G.) &2J\\\"\\\"6J7K0M*;\\\".G &;!.A &2@\\\"\\\"6@7A.5 &2F\\\"\\\"6F7G.) &2J\\\"\\\"6J7K&/#$+\\\")(\\\"'#&'#/& 8!:\\xD2! )\"),\n        peg$decode(\";\\x81.# &;\\x82\"),\n        peg$decode(\"%%;O/2#2:\\\"\\\"6:7;/#$+\\\")(\\\"'#&'#.\\\" &\\\"/,#;S/#$+\\\")(\\\"'#&'#.\\\" &\\\"\"),\n        peg$decode(\"$;+.\\x83 &;-.} &2B\\\"\\\"6B7C.q &2D\\\"\\\"6D7E.e &22\\\"\\\"6273.Y &28\\\"\\\"6879.M &2:\\\"\\\"6:7;.A &2<\\\"\\\"6<7=.5 &2>\\\"\\\"6>7?.) &2@\\\"\\\"6@7A/\\x8C#0\\x89*;+.\\x83 &;-.} &2B\\\"\\\"6B7C.q &2D\\\"\\\"6D7E.e &22\\\"\\\"6273.Y &28\\\"\\\"6879.M &2:\\\"\\\"6:7;.A &2<\\\"\\\"6<7=.5 &2>\\\"\\\"6>7?.) &2@\\\"\\\"6@7A&&&#\"),\n        peg$decode(\"$;y0#*;y&\"),\n        peg$decode(\"%3\\x92\\\"\\\"5#7\\xD3/q#24\\\"\\\"6475/b$$;!/&#0#*;!&&&#/L$2J\\\"\\\"6J7K/=$$;!/&#0#*;!&&&#/'$8%:\\xD4% )(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"2\\xD5\\\"\\\"6\\xD57\\xD6\"),\n        peg$decode(\"2\\xD7\\\"\\\"6\\xD77\\xD8\"),\n        peg$decode(\"2\\xD9\\\"\\\"6\\xD97\\xDA\"),\n        peg$decode(\"2\\xDB\\\"\\\"6\\xDB7\\xDC\"),\n        peg$decode(\"2\\xDD\\\"\\\"6\\xDD7\\xDE\"),\n        peg$decode(\"2\\xDF\\\"\\\"6\\xDF7\\xE0\"),\n        peg$decode(\"2\\xE1\\\"\\\"6\\xE17\\xE2\"),\n        peg$decode(\"2\\xE3\\\"\\\"6\\xE37\\xE4\"),\n        peg$decode(\"2\\xE5\\\"\\\"6\\xE57\\xE6\"),\n        peg$decode(\"2\\xE7\\\"\\\"6\\xE77\\xE8\"),\n        peg$decode(\"2\\xE9\\\"\\\"6\\xE97\\xEA\"),\n        peg$decode(\"%;\\x85.Y &;\\x86.S &;\\x88.M &;\\x89.G &;\\x8A.A &;\\x8B.; &;\\x8C.5 &;\\x8F./ &;\\x8D.) &;\\x8E.# &;6/& 8!:\\xEB! )\"),\n        peg$decode(\"%;\\x84/G#;'/>$;\\x92/5$;'/,$;\\x94/#$+%)(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;\\x93/' 8!:\\xEC!! )\"),\n        peg$decode(\"%;!/5#;!/,$;!/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(0G*;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(&/& 8!:\\xED! )\"),\n        peg$decode(\"%;\\xB6/Y#$%;A/,#;\\xB6/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xB6/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;9/N#%2:\\\"\\\"6:7;/,#;9/#$+\\\")(\\\"'#&'#.\\\" &\\\"/'$8\\\":\\xEE\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;:.c &%;\\x98/Y#$%;A/,#;\\x98/#$+\\\")(\\\"'#&'#06*%;A/,#;\\x98/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#/& 8!:\\xEF! )\"),\n        peg$decode(\"%;L.# &;\\x99/]#$%;B/,#;\\x9B/#$+\\\")(\\\"'#&'#06*%;B/,#;\\x9B/#$+\\\")(\\\"'#&'#&/'$8\\\":\\xF0\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;\\x9A.\\\" &\\\"/>#;@/5$;M/,$;?/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%%;6/Y#$%;./,#;6/#$+\\\")(\\\"'#&'#06*%;./,#;6/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#.# &;H/' 8!:\\xF1!! )\"),\n        peg$decode(\";\\x9C.) &;\\x9D.# &;\\xA0\"),\n        peg$decode(\"%3\\xF2\\\"\\\"5!7\\xF3/:#;</1$;\\x9F/($8#:\\xF4#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\xF5\\\"\\\"5'7\\xF6/:#;</1$;\\x9E/($8#:\\xF7#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\xF8!! )\"),\n        peg$decode(\"%2\\xF9\\\"\\\"6\\xF97\\xFA/o#%2J\\\"\\\"6J7K/M#;!.\\\" &\\\"/?$;!.\\\" &\\\"/1$;!.\\\" &\\\"/#$+$)($'#(#'#(\\\"'#&'#.\\\" &\\\"/'$8\\\":\\xFB\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;6/J#%;</,#;\\xA1/#$+\\\")(\\\"'#&'#.\\\" &\\\"/)$8\\\":\\xFC\\\"\\\"! )(\\\"'#&'#\"),\n        peg$decode(\";6.) &;T.# &;H\"),\n        peg$decode(\"%;\\xA3/Y#$%;B/,#;\\xA4/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA4/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%3\\xFD\\\"\\\"5&7\\xFE.G &3\\xFF\\\"\\\"5'7\\u0100.; &3\\u0101\\\"\\\"5$7\\u0102./ &3\\u0103\\\"\\\"5%7\\u0104.# &;6/& 8!:\\u0105! )\"),\n        peg$decode(\";\\xA5.# &;\\xA0\"),\n        peg$decode(\"%3\\u0106\\\"\\\"5(7\\u0107/M#;</D$3\\u0108\\\"\\\"5(7\\u0109./ &3\\u010A\\\"\\\"5(7\\u010B.# &;6/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;6/Y#$%;A/,#;6/#$+\\\")(\\\"'#&'#06*%;A/,#;6/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\u010C!! )\"),\n        peg$decode(\"%;\\xA9/& 8!:\\u010D! )\"),\n        peg$decode(\"%;\\xAA/k#;;/b$;\\xAF/Y$$%;B/,#;\\xB0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xB0/#$+\\\")(\\\"'#&'#&/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";\\xAB.# &;\\xAC\"),\n        peg$decode(\"3\\u010E\\\"\\\"5$7\\u010F.S &3\\u0110\\\"\\\"5%7\\u0111.G &3\\u0112\\\"\\\"5%7\\u0113.; &3\\u0114\\\"\\\"5%7\\u0115./ &3\\u0116\\\"\\\"5+7\\u0117.# &;\\xAD\"),\n        peg$decode(\"3\\u0118\\\"\\\"5'7\\u0119./ &3\\u011A\\\"\\\"5)7\\u011B.# &;\\xAD\"),\n        peg$decode(\";6.# &;\\xAE\"),\n        peg$decode(\"%3\\u011C\\\"\\\"5\\\"7\\u011D/,#;6/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\";\\xAD.# &;6\"),\n        peg$decode(\"%;6/5#;</,$;\\xB1/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\";6.# &;H\"),\n        peg$decode(\"%;\\xB3/5#;./,$;\\x90/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\u011E!! )\"),\n        peg$decode(\"%;\\x9E/' 8!:\\u011F!! )\"),\n        peg$decode(\"%;\\xB6/^#$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/($8\\\":\\u0120\\\"!!)(\\\"'#&'#\"),\n        peg$decode(\"%%;7/e#$%2J\\\"\\\"6J7K/,#;7/#$+\\\")(\\\"'#&'#0<*%2J\\\"\\\"6J7K/,#;7/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#/\\\"!&,)\"),\n        peg$decode(\"%;L.# &;\\x99/]#$%;B/,#;\\xB8/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xB8/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u0121\\\" )(\\\"'#&'#\"),\n        peg$decode(\";\\xB9.# &;\\xA0\"),\n        peg$decode(\"%3\\u0122\\\"\\\"5#7\\u0123/:#;</1$;6/($8#:\\u0124#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\u0125!! )\"),\n        peg$decode(\"%;\\x9E/' 8!:\\u0126!! )\"),\n        peg$decode(\"%$;\\x9A0#*;\\x9A&/x#;@/o$;M/f$;?/]$$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/'$8%:\\u0127% )(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";\\xBE\"),\n        peg$decode(\"%3\\u0128\\\"\\\"5&7\\u0129/k#;./b$;\\xC1/Y$$%;A/,#;\\xC1/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xC1/#$+\\\")(\\\"'#&'#&/#$+$)($'#(#'#(\\\"'#&'#.# &;\\xBF\"),\n        peg$decode(\"%;6/k#;./b$;\\xC0/Y$$%;A/,#;\\xC0/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xC0/#$+\\\")(\\\"'#&'#&/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;6/;#;</2$;6.# &;H/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\";\\xC2.G &;\\xC4.A &;\\xC6.; &;\\xC8.5 &;\\xC9./ &;\\xCA.) &;\\xCB.# &;\\xC0\"),\n        peg$decode(\"%3\\u012A\\\"\\\"5%7\\u012B/5#;</,$;\\xC3/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;I/' 8!:\\u012C!! )\"),\n        peg$decode(\"%3\\u012D\\\"\\\"5&7\\u012E/\\x97#;</\\x8E$;D/\\x85$;\\xC5/|$$%$;'/&#0#*;'&&&#/,#;\\xC5/#$+\\\")(\\\"'#&'#0C*%$;'/&#0#*;'&&&#/,#;\\xC5/#$+\\\")(\\\"'#&'#&/,$;E/#$+&)(&'#(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";t.# &;w\"),\n        peg$decode(\"%3\\u012F\\\"\\\"5%7\\u0130/5#;</,$;\\xC7/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;I/' 8!:\\u0131!! )\"),\n        peg$decode(\"%3\\u0132\\\"\\\"5&7\\u0133/:#;</1$;I/($8#:\\u0134#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0135\\\"\\\"5%7\\u0136/]#;</T$%3\\u0137\\\"\\\"5$7\\u0138/& 8!:\\u0139! ).4 &%3\\u013A\\\"\\\"5%7\\u013B/& 8!:\\u013C! )/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u013D\\\"\\\"5)7\\u013E/R#;</I$3\\u013F\\\"\\\"5#7\\u0140./ &3\\u0141\\\"\\\"5(7\\u0142.# &;6/($8#:\\u0143#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0144\\\"\\\"5#7\\u0145/\\x93#;</\\x8A$;D/\\x81$%;\\xCC/e#$%2D\\\"\\\"6D7E/,#;\\xCC/#$+\\\")(\\\"'#&'#0<*%2D\\\"\\\"6D7E/,#;\\xCC/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#/,$;E/#$+%)(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0146\\\"\\\"5(7\\u0147./ &3\\u0148\\\"\\\"5$7\\u0149.# &;6/' 8!:\\u014A!! )\"),\n        peg$decode(\"%;6/Y#$%;A/,#;6/#$+\\\")(\\\"'#&'#06*%;A/,#;6/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;\\xCF/G#;./>$;\\xCF/5$;./,$;\\x90/#$+%)(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\u014B!! )\"),\n        peg$decode(\"%;\\xD1/]#$%;A/,#;\\xD1/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xD1/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u014C\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;\\x99/]#$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u014D\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;L.O &;\\x99.I &%;@.\\\" &\\\"/:#;t/1$;?.\\\" &\\\"/#$+#)(#'#(\\\"'#&'#/]#$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u014E\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;\\xD4/]#$%;B/,#;\\xD5/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xD5/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u014F\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;\\x96/& 8!:\\u0150! )\"),\n        peg$decode(\"%3\\u0151\\\"\\\"5(7\\u0152/:#;</1$;6/($8#:\\u0153#! )(#'#(\\\"'#&'#.g &%3\\u0154\\\"\\\"5&7\\u0155/:#;</1$;6/($8#:\\u0156#! )(#'#(\\\"'#&'#.: &%3\\u0157\\\"\\\"5*7\\u0158/& 8!:\\u0159! ).# &;\\xA0\"),\n        peg$decode(\"%%;6/k#$%;A/2#;6/)$8\\\":\\u015A\\\"\\\"$ )(\\\"'#&'#0<*%;A/2#;6/)$8\\\":\\u015A\\\"\\\"$ )(\\\"'#&'#&/)$8\\\":\\u015B\\\"\\\"! )(\\\"'#&'#.\\\" &\\\"/' 8!:\\u015C!! )\"),\n        peg$decode(\"%;\\xD8/Y#$%;A/,#;\\xD8/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xD8/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;\\x99/Y#$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\u015D!! )\"),\n        peg$decode(\"%;\\xDB/Y#$%;B/,#;\\xDC/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xDC/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%3\\u015E\\\"\\\"5&7\\u015F.; &3\\u0160\\\"\\\"5'7\\u0161./ &3\\u0162\\\"\\\"5*7\\u0163.# &;6/& 8!:\\u0164! )\"),\n        peg$decode(\"%3\\u0165\\\"\\\"5&7\\u0166/:#;</1$;\\xDD/($8#:\\u0167#! )(#'#(\\\"'#&'#.} &%3\\xF5\\\"\\\"5'7\\xF6/:#;</1$;\\x9E/($8#:\\u0168#! )(#'#(\\\"'#&'#.P &%3\\u0169\\\"\\\"5+7\\u016A/:#;</1$;\\x9E/($8#:\\u016B#! )(#'#(\\\"'#&'#.# &;\\xA0\"),\n        peg$decode(\"3\\u016C\\\"\\\"5+7\\u016D.k &3\\u016E\\\"\\\"5)7\\u016F._ &3\\u0170\\\"\\\"5(7\\u0171.S &3\\u0172\\\"\\\"5'7\\u0173.G &3\\u0174\\\"\\\"5&7\\u0175.; &3\\u0176\\\"\\\"5*7\\u0177./ &3\\u0178\\\"\\\"5)7\\u0179.# &;6\"),\n        peg$decode(\";1.\\\" &\\\"\"),\n        peg$decode(\"%%;6/k#$%;A/2#;6/)$8\\\":\\u015A\\\"\\\"$ )(\\\"'#&'#0<*%;A/2#;6/)$8\\\":\\u015A\\\"\\\"$ )(\\\"'#&'#&/)$8\\\":\\u015B\\\"\\\"! )(\\\"'#&'#.\\\" &\\\"/' 8!:\\u017A!! )\"),\n        peg$decode(\"%;L.# &;\\x99/]#$%;B/,#;\\xE1/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xE1/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u017B\\\" )(\\\"'#&'#\"),\n        peg$decode(\";\\xB9.# &;\\xA0\"),\n        peg$decode(\"%;\\xE3/Y#$%;A/,#;\\xE3/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xE3/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;\\xEA/k#;./b$;\\xED/Y$$%;B/,#;\\xE4/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xE4/#$+\\\")(\\\"'#&'#&/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";\\xE5.; &;\\xE6.5 &;\\xE7./ &;\\xE8.) &;\\xE9.# &;\\xA0\"),\n        peg$decode(\"%3\\u017C\\\"\\\"5#7\\u017D/:#;</1$;\\xF0/($8#:\\u017E#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u017F\\\"\\\"5%7\\u0180/:#;</1$;T/($8#:\\u0181#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0182\\\"\\\"5(7\\u0183/F#;</=$;\\\\.) &;Y.# &;X/($8#:\\u0184#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0185\\\"\\\"5&7\\u0186/:#;</1$;6/($8#:\\u0187#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0188\\\"\\\"5%7\\u0189/A#;</8$$;!0#*;!&/($8#:\\u018A#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;\\xEB/G#;;/>$;6/5$;;/,$;\\xEC/#$+%)(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\x92\\\"\\\"5#7\\xD3.# &;6/' 8!:\\u018B!! )\"),\n        peg$decode(\"%3\\xB1\\\"\\\"5#7\\u018C.G &3\\xB3\\\"\\\"5#7\\u018D.; &3\\xB7\\\"\\\"5#7\\u018E./ &3\\xB5\\\"\\\"5$7\\u018F.# &;6/' 8!:\\u0190!! )\"),\n        peg$decode(\"%;\\xEE/D#%;C/,#;\\xEF/#$+\\\")(\\\"'#&'#.\\\" &\\\"/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;U.) &;\\\\.# &;X/& 8!:\\u0191! )\"),\n        peg$decode(\"%%;!.\\\" &\\\"/[#;!.\\\" &\\\"/M$;!.\\\" &\\\"/?$;!.\\\" &\\\"/1$;!.\\\" &\\\"/#$+%)(%'#($'#(#'#(\\\"'#&'#/' 8!:\\u0192!! )\"),\n        peg$decode(\"%%;!/?#;!.\\\" &\\\"/1$;!.\\\" &\\\"/#$+#)(#'#(\\\"'#&'#/' 8!:\\u0193!! )\"),\n        peg$decode(\";\\xBE\"),\n        peg$decode(\"%;\\x9E/^#$%;B/,#;\\xF3/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xF3/#$+\\\")(\\\"'#&'#&/($8\\\":\\u0194\\\"!!)(\\\"'#&'#\"),\n        peg$decode(\";\\xF4.# &;\\xA0\"),\n        peg$decode(\"%2\\u0195\\\"\\\"6\\u01957\\u0196/L#;</C$2\\u0197\\\"\\\"6\\u01977\\u0198.) &2\\u0199\\\"\\\"6\\u01997\\u019A/($8#:\\u019B#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;\\x9E/^#$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/($8\\\":\\u019C\\\"!!)(\\\"'#&'#\"),\n        peg$decode(\"%;6/5#;0/,$;\\xF7/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"$;2.) &;4.# &;.0/*;2.) &;4.# &;.&\"),\n        peg$decode(\"$;%0#*;%&\"),\n        peg$decode(\"%;\\xFA/;#28\\\"\\\"6879/,$;\\xFB/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u019D\\\"\\\"5%7\\u019E.) &3\\u019F\\\"\\\"5$7\\u01A0/' 8!:\\u01A1!! )\"),\n        peg$decode(\"%;\\xFC/J#%28\\\"\\\"6879/,#;^/#$+\\\")(\\\"'#&'#.\\\" &\\\"/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;\\\\.) &;X.# &;\\x82/' 8!:\\u01A2!! )\"),\n        peg$decode(\";\\\".S &;!.M &2F\\\"\\\"6F7G.A &2J\\\"\\\"6J7K.5 &2H\\\"\\\"6H7I.) &2N\\\"\\\"6N7O\"),\n        peg$decode(\"2L\\\"\\\"6L7M.\\x95 &2B\\\"\\\"6B7C.\\x89 &2<\\\"\\\"6<7=.} &2R\\\"\\\"6R7S.q &2T\\\"\\\"6T7U.e &2V\\\"\\\"6V7W.Y &2P\\\"\\\"6P7Q.M &2@\\\"\\\"6@7A.A &2D\\\"\\\"6D7E.5 &22\\\"\\\"6273.) &2>\\\"\\\"6>7?\"),\n        peg$decode(\"%;\\u0100/b#28\\\"\\\"6879/S$;\\xFB/J$%2\\u01A3\\\"\\\"6\\u01A37\\u01A4/,#;\\xEC/#$+\\\")(\\\"'#&'#.\\\" &\\\"/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u01A5\\\"\\\"5%7\\u01A6.) &3\\u01A7\\\"\\\"5$7\\u01A8/' 8!:\\u01A1!! )\"),\n        peg$decode(\"%3\\xB1\\\"\\\"5#7\\xB2.6 &3\\xB3\\\"\\\"5#7\\xB4.* &$;+0#*;+&/' 8!:\\u01A9!! )\"),\n        peg$decode(\"%;\\u0104/\\x87#2F\\\"\\\"6F7G/x$;\\u0103/o$2F\\\"\\\"6F7G/`$;\\u0103/W$2F\\\"\\\"6F7G/H$;\\u0103/?$2F\\\"\\\"6F7G/0$;\\u0105/'$8):\\u01AA) )()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;#/>#;#/5$;#/,$;#/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;\\u0103/,#;\\u0103/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;\\u0103/5#;\\u0103/,$;\\u0103/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;q/T#$;m0#*;m&/D$%; /,#;\\xF8/#$+\\\")(\\\"'#&'#.\\\" &\\\"/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%2\\u01AB\\\"\\\"6\\u01AB7\\u01AC.) &2\\u01AD\\\"\\\"6\\u01AD7\\u01AE/w#;0/n$;\\u0108/e$$%;B/2#;\\u0109.# &;\\xA0/#$+\\\")(\\\"'#&'#0<*%;B/2#;\\u0109.# &;\\xA0/#$+\\\")(\\\"'#&'#&/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";\\x99.# &;L\"),\n        peg$decode(\"%2\\u01AF\\\"\\\"6\\u01AF7\\u01B0/5#;</,$;\\u010A/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;D/S#;,/J$2:\\\"\\\"6:7;/;$;,.# &;T/,$;E/#$+%)(%'#($'#(#'#(\\\"'#&'#\")\n    ];\n    let peg$currPos = 0;\n    let peg$savedPos = 0;\n    const peg$posDetailsCache = [{ line: 1, column: 1 }];\n    let peg$maxFailPos = 0;\n    let peg$maxFailExpected = [];\n    let peg$silentFails = 0;\n    let peg$result;\n    if (options.startRule !== undefined) {\n        if (!(options.startRule in peg$startRuleIndices)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n        }\n        peg$startRuleIndex = peg$startRuleIndices[options.startRule];\n    }\n    function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n    }\n    function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location1) {\n        location1 = location1 !== undefined\n            ? location1\n            : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location1);\n    }\n    function error(message, location1) {\n        location1 = location1 !== undefined\n            ? location1\n            : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location1);\n    }\n    function peg$literalExpectation(text1, ignoreCase) {\n        return { type: \"literal\", text: text1, ignoreCase: ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n    function peg$anyExpectation() {\n        return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n        return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n        return { type: \"other\", description: description };\n    }\n    function peg$computePosDetails(pos) {\n        let details = peg$posDetailsCache[pos];\n        let p;\n        if (details) {\n            return details;\n        }\n        else {\n            p = pos - 1;\n            while (!peg$posDetailsCache[p]) {\n                p--;\n            }\n            details = peg$posDetailsCache[p];\n            details = {\n                line: details.line,\n                column: details.column\n            };\n            while (p < pos) {\n                if (input.charCodeAt(p) === 10) {\n                    details.line++;\n                    details.column = 1;\n                }\n                else {\n                    details.column++;\n                }\n                p++;\n            }\n            peg$posDetailsCache[pos] = details;\n            return details;\n        }\n    }\n    function peg$computeLocation(startPos, endPos) {\n        const startPosDetails = peg$computePosDetails(startPos);\n        const endPosDetails = peg$computePosDetails(endPos);\n        return {\n            source: peg$source,\n            start: {\n                offset: startPos,\n                line: startPosDetails.line,\n                column: startPosDetails.column\n            },\n            end: {\n                offset: endPos,\n                line: endPosDetails.line,\n                column: endPosDetails.column\n            }\n        };\n    }\n    function peg$fail(expected1) {\n        if (peg$currPos < peg$maxFailPos) {\n            return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected1);\n    }\n    function peg$buildSimpleError(message, location1) {\n        return new SyntaxError(message, [], \"\", location1);\n    }\n    function peg$buildStructuredError(expected1, found, location1) {\n        return new SyntaxError(SyntaxError.buildMessage(expected1, found), expected1, found, location1);\n    }\n    function peg$decode(s) {\n        return s.split(\"\").map((ch) => ch.charCodeAt(0) - 32);\n    }\n    function peg$parseRule(index) {\n        const bc = peg$bytecode[index];\n        let ip = 0;\n        const ips = [];\n        let end = bc.length;\n        const ends = [];\n        const stack = [];\n        let params;\n        while (true) {\n            while (ip < end) {\n                switch (bc[ip]) {\n                    case 0:\n                        stack.push(peg$consts[bc[ip + 1]]);\n                        ip += 2;\n                        break;\n                    case 1:\n                        stack.push(undefined);\n                        ip++;\n                        break;\n                    case 2:\n                        stack.push(null);\n                        ip++;\n                        break;\n                    case 3:\n                        stack.push(peg$FAILED);\n                        ip++;\n                        break;\n                    case 4:\n                        stack.push([]);\n                        ip++;\n                        break;\n                    case 5:\n                        stack.push(peg$currPos);\n                        ip++;\n                        break;\n                    case 6:\n                        stack.pop();\n                        ip++;\n                        break;\n                    case 7:\n                        peg$currPos = stack.pop();\n                        ip++;\n                        break;\n                    case 8:\n                        stack.length -= bc[ip + 1];\n                        ip += 2;\n                        break;\n                    case 9:\n                        stack.splice(-2, 1);\n                        ip++;\n                        break;\n                    case 10:\n                        stack[stack.length - 2].push(stack.pop());\n                        ip++;\n                        break;\n                    case 11:\n                        stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));\n                        ip += 2;\n                        break;\n                    case 12:\n                        stack.push(input.substring(stack.pop(), peg$currPos));\n                        ip++;\n                        break;\n                    case 13:\n                        ends.push(end);\n                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n                        if (stack[stack.length - 1]) {\n                            end = ip + 3 + bc[ip + 1];\n                            ip += 3;\n                        }\n                        else {\n                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                            ip += 3 + bc[ip + 1];\n                        }\n                        break;\n                    case 14:\n                        ends.push(end);\n                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n                        if (stack[stack.length - 1] === peg$FAILED) {\n                            end = ip + 3 + bc[ip + 1];\n                            ip += 3;\n                        }\n                        else {\n                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                            ip += 3 + bc[ip + 1];\n                        }\n                        break;\n                    case 15:\n                        ends.push(end);\n                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n                        if (stack[stack.length - 1] !== peg$FAILED) {\n                            end = ip + 3 + bc[ip + 1];\n                            ip += 3;\n                        }\n                        else {\n                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                            ip += 3 + bc[ip + 1];\n                        }\n                        break;\n                    case 16:\n                        if (stack[stack.length - 1] !== peg$FAILED) {\n                            ends.push(end);\n                            ips.push(ip);\n                            end = ip + 2 + bc[ip + 1];\n                            ip += 2;\n                        }\n                        else {\n                            ip += 2 + bc[ip + 1];\n                        }\n                        break;\n                    case 17:\n                        ends.push(end);\n                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n                        if (input.length > peg$currPos) {\n                            end = ip + 3 + bc[ip + 1];\n                            ip += 3;\n                        }\n                        else {\n                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                            ip += 3 + bc[ip + 1];\n                        }\n                        break;\n                    case 18:\n                        ends.push(end);\n                        ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n                        if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {\n                            end = ip + 4 + bc[ip + 2];\n                            ip += 4;\n                        }\n                        else {\n                            end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                            ip += 4 + bc[ip + 2];\n                        }\n                        break;\n                    case 19:\n                        ends.push(end);\n                        ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n                        if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {\n                            end = ip + 4 + bc[ip + 2];\n                            ip += 4;\n                        }\n                        else {\n                            end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                            ip += 4 + bc[ip + 2];\n                        }\n                        break;\n                    case 20:\n                        ends.push(end);\n                        ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n                        if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {\n                            end = ip + 4 + bc[ip + 2];\n                            ip += 4;\n                        }\n                        else {\n                            end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                            ip += 4 + bc[ip + 2];\n                        }\n                        break;\n                    case 21:\n                        stack.push(input.substr(peg$currPos, bc[ip + 1]));\n                        peg$currPos += bc[ip + 1];\n                        ip += 2;\n                        break;\n                    case 22:\n                        stack.push(peg$consts[bc[ip + 1]]);\n                        peg$currPos += peg$consts[bc[ip + 1]].length;\n                        ip += 2;\n                        break;\n                    case 23:\n                        stack.push(peg$FAILED);\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$consts[bc[ip + 1]]);\n                        }\n                        ip += 2;\n                        break;\n                    case 24:\n                        peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];\n                        ip += 2;\n                        break;\n                    case 25:\n                        peg$savedPos = peg$currPos;\n                        ip++;\n                        break;\n                    case 26:\n                        params = bc.slice(ip + 4, ip + 4 + bc[ip + 3])\n                            .map(function (p) { return stack[stack.length - 1 - p]; });\n                        stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));\n                        ip += 4 + bc[ip + 3];\n                        break;\n                    case 27:\n                        stack.push(peg$parseRule(bc[ip + 1]));\n                        ip += 2;\n                        break;\n                    case 28:\n                        peg$silentFails++;\n                        ip++;\n                        break;\n                    case 29:\n                        peg$silentFails--;\n                        ip++;\n                        break;\n                    default:\n                        throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n                }\n            }\n            if (ends.length > 0) {\n                end = ends.pop();\n                ip = ips.pop();\n            }\n            else {\n                break;\n            }\n        }\n        return stack[0];\n    }\n    options.data = {}; // Object to which header attributes will be assigned during parsing\n    function list(head, tail) {\n        return [head].concat(tail);\n    }\n    peg$result = peg$parseRule(peg$startRuleIndex);\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n    }\n    else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length\n            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n}\nexport const parse = peg$parse;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Parameters } from \"./parameters.js\";\n/**\n * URI.\n * @public\n */\nexport class URI extends Parameters {\n    /**\n     * Constructor\n     * @param scheme -\n     * @param user -\n     * @param host -\n     * @param port -\n     * @param parameters -\n     * @param headers -\n     */\n    constructor(scheme = \"sip\", user, host, port, parameters, headers) {\n        super(parameters || {});\n        this.headers = {};\n        // Checks\n        if (!host) {\n            throw new TypeError('missing or invalid \"host\" parameter');\n        }\n        for (const header in headers) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (headers.hasOwnProperty(header)) {\n                this.setHeader(header, headers[header]);\n            }\n        }\n        // Raw URI\n        this.raw = {\n            scheme,\n            user,\n            host,\n            port\n        };\n        // Normalized URI\n        this.normal = {\n            scheme: scheme.toLowerCase(),\n            user,\n            host: host.toLowerCase(),\n            port\n        };\n    }\n    get scheme() { return this.normal.scheme; }\n    set scheme(value) {\n        this.raw.scheme = value;\n        this.normal.scheme = value.toLowerCase();\n    }\n    get user() { return this.normal.user; }\n    set user(value) {\n        this.normal.user = this.raw.user = value;\n    }\n    get host() { return this.normal.host; }\n    set host(value) {\n        this.raw.host = value;\n        this.normal.host = value.toLowerCase();\n    }\n    get aor() { return this.normal.user + \"@\" + this.normal.host; }\n    get port() { return this.normal.port; }\n    set port(value) {\n        this.normal.port = this.raw.port = value === 0 ? value : value;\n    }\n    setHeader(name, value) {\n        this.headers[this.headerize(name)] = (value instanceof Array) ? value : [value];\n    }\n    getHeader(name) {\n        if (name) {\n            return this.headers[this.headerize(name)];\n        }\n    }\n    hasHeader(name) {\n        // eslint-disable-next-line no-prototype-builtins\n        return !!name && !!this.headers.hasOwnProperty(this.headerize(name));\n    }\n    deleteHeader(header) {\n        header = this.headerize(header);\n        // eslint-disable-next-line no-prototype-builtins\n        if (this.headers.hasOwnProperty(header)) {\n            const value = this.headers[header];\n            delete this.headers[header];\n            return value;\n        }\n    }\n    clearHeaders() {\n        this.headers = {};\n    }\n    clone() {\n        return new URI(this._raw.scheme, this._raw.user || \"\", this._raw.host, this._raw.port, JSON.parse(JSON.stringify(this.parameters)), JSON.parse(JSON.stringify(this.headers)));\n    }\n    toRaw() {\n        return this._toString(this._raw);\n    }\n    toString() {\n        return this._toString(this._normal);\n    }\n    get _normal() { return this.normal; }\n    get _raw() { return this.raw; }\n    _toString(uri) {\n        let uriString = uri.scheme + \":\";\n        // add slashes if it's not a sip(s) URI\n        if (!uri.scheme.toLowerCase().match(\"^sips?$\")) {\n            uriString += \"//\";\n        }\n        if (uri.user) {\n            uriString += this.escapeUser(uri.user) + \"@\";\n        }\n        uriString += uri.host;\n        if (uri.port || uri.port === 0) {\n            uriString += \":\" + uri.port;\n        }\n        for (const parameter in this.parameters) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (this.parameters.hasOwnProperty(parameter)) {\n                uriString += \";\" + parameter;\n                if (this.parameters[parameter] !== null) {\n                    uriString += \"=\" + this.parameters[parameter];\n                }\n            }\n        }\n        const headers = [];\n        for (const header in this.headers) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (this.headers.hasOwnProperty(header)) {\n                // eslint-disable-next-line @typescript-eslint/no-for-in-array\n                for (const idx in this.headers[header]) {\n                    // eslint-disable-next-line no-prototype-builtins\n                    if (this.headers[header].hasOwnProperty(idx)) {\n                        headers.push(header + \"=\" + this.headers[header][idx]);\n                    }\n                }\n            }\n        }\n        if (headers.length > 0) {\n            uriString += \"?\" + headers.join(\"&\");\n        }\n        return uriString;\n    }\n    /*\n     * Hex-escape a SIP URI user.\n     * @private\n     * @param {String} user\n     */\n    escapeUser(user) {\n        let decodedUser;\n        // FIXME: This is called by toString above which should never throw, but\n        // decodeURIComponent can throw and I've seen one case in production where\n        // it did throw resulting in a cascading failure. This class should be\n        // fixed so that decodeURIComponent is not called at this point (in toString).\n        // The user should be decoded when the URI is constructor or some other\n        // place where we can catch the error before the URI is created or somesuch.\n        // eslint-disable-next-line no-useless-catch\n        try {\n            decodedUser = decodeURIComponent(user);\n        }\n        catch (error) {\n            throw error;\n        }\n        // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n        return encodeURIComponent(decodedUser)\n            .replace(/%3A/ig, \":\")\n            .replace(/%2B/ig, \"+\")\n            .replace(/%3F/ig, \"?\")\n            .replace(/%2F/ig, \"/\");\n    }\n    headerize(str) {\n        const exceptions = {\n            \"Call-Id\": \"Call-ID\",\n            \"Cseq\": \"CSeq\",\n            \"Min-Se\": \"Min-SE\",\n            \"Rack\": \"RAck\",\n            \"Rseq\": \"RSeq\",\n            \"Www-Authenticate\": \"WWW-Authenticate\",\n        };\n        const name = str.toLowerCase().replace(/_/g, \"-\").split(\"-\");\n        const parts = name.length;\n        let hname = \"\";\n        for (let part = 0; part < parts; part++) {\n            if (part !== 0) {\n                hname += \"-\";\n            }\n            hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);\n        }\n        if (exceptions[hname]) {\n            hname = exceptions[hname];\n        }\n        return hname;\n    }\n}\n/**\n * Returns true if URIs are equivalent per RFC 3261 Section 19.1.4.\n * @param a - URI to compare\n * @param b - URI to compare\n *\n * @remarks\n * 19.1.4 URI Comparison\n * Some operations in this specification require determining whether two\n * SIP or SIPS URIs are equivalent.\n *\n * https://tools.ietf.org/html/rfc3261#section-19.1.4\n * @internal\n */\nexport function equivalentURI(a, b) {\n    // o  A SIP and SIPS URI are never equivalent.\n    if (a.scheme !== b.scheme) {\n        return false;\n    }\n    // o  Comparison of the userinfo of SIP and SIPS URIs is case-\n    //    sensitive.  This includes userinfo containing passwords or\n    //    formatted as telephone-subscribers.  Comparison of all other\n    //    components of the URI is case-insensitive unless explicitly\n    //    defined otherwise.\n    //\n    // o  The ordering of parameters and header fields is not significant\n    //    in comparing SIP and SIPS URIs.\n    //\n    // o  Characters other than those in the \"reserved\" set (see RFC 2396\n    //    [5]) are equivalent to their \"\"%\" HEX HEX\" encoding.\n    //\n    // o  An IP address that is the result of a DNS lookup of a host name\n    //    does not match that host name.\n    //\n    // o  For two URIs to be equal, the user, password, host, and port\n    //    components must match.\n    //\n    // A URI omitting the user component will not match a URI that\n    // includes one.  A URI omitting the password component will not\n    // match a URI that includes one.\n    //\n    // A URI omitting any component with a default value will not\n    // match a URI explicitly containing that component with its\n    // default value.  For instance, a URI omitting the optional port\n    // component will not match a URI explicitly declaring port 5060.\n    // The same is true for the transport-parameter, ttl-parameter,\n    // user-parameter, and method components.\n    //\n    // Defining sip:user@host to not be equivalent to\n    // sip:user@host:5060 is a change from RFC 2543.  When deriving\n    // addresses from URIs, equivalent addresses are expected from\n    // equivalent URIs.  The URI sip:user@host:5060 will always\n    // resolve to port 5060.  The URI sip:user@host may resolve to\n    // other ports through the DNS SRV mechanisms detailed in [4].\n    // FIXME: TODO:\n    // - character compared to hex encoding is not handled\n    // - password does not exist on URI currently\n    if (a.user !== b.user || a.host !== b.host || a.port !== b.port) {\n        return false;\n    }\n    // o  URI uri-parameter components are compared as follows:\n    function compareParameters(a, b) {\n        //  -  Any uri-parameter appearing in both URIs must match.\n        const parameterKeysA = Object.keys(a.parameters);\n        const parameterKeysB = Object.keys(b.parameters);\n        const intersection = parameterKeysA.filter(x => parameterKeysB.includes(x));\n        if (!intersection.every(key => a.parameters[key] === b.parameters[key])) {\n            return false;\n        }\n        //  -  A user, ttl, or method uri-parameter appearing in only one\n        //     URI never matches, even if it contains the default value.\n        if (![\"user\", \"ttl\", \"method\", \"transport\"].every(key => a.hasParam(key) && b.hasParam(key) || !a.hasParam(key) && !b.hasParam(key))) {\n            return false;\n        }\n        //  -  A URI that includes an maddr parameter will not match a URI\n        //     that contains no maddr parameter.\n        if (![\"maddr\"].every(key => a.hasParam(key) && b.hasParam(key) || !a.hasParam(key) && !b.hasParam(key))) {\n            return false;\n        }\n        //  -  All other uri-parameters appearing in only one URI are\n        //     ignored when comparing the URIs.\n        return true;\n    }\n    if (!compareParameters(a, b)) {\n        return false;\n    }\n    // o  URI header components are never ignored.  Any present header\n    //    component MUST be present in both URIs and match for the URIs\n    //    to match.  The matching rules are defined for each header field\n    //    in Section 20.\n    const headerKeysA = Object.keys(a.headers);\n    const headerKeysB = Object.keys(b.headers);\n    // No need to check if no headers\n    if (headerKeysA.length !== 0 || headerKeysB.length !== 0) {\n        // Must have same number of headers\n        if (headerKeysA.length !== headerKeysB.length) {\n            return false;\n        }\n        // Must have same headers\n        const intersection = headerKeysA.filter(x => headerKeysB.includes(x));\n        if (intersection.length !== headerKeysB.length) {\n            return false;\n        }\n        // FIXME: Not to spec. But perhaps not worth fixing?\n        // Must have same header values\n        // It seems too much to consider multiple headers with same name.\n        // It seems too much to compare two header params according to the rule of each header.\n        // We'll assume a single header and compare them string to string...\n        if (!intersection.every(key => a.headers[key].length && b.headers[key].length && a.headers[key][0] === b.headers[key][0])) {\n            return false;\n        }\n    }\n    return true;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Levels as LogLevels } from 'sip.js/lib/core/log/levels';\nimport { UserAgent, Web, } from 'sip.js';\nimport { createWebPhoneUserAgent } from './userAgent';\nimport { default as MediaStreams, MediaStreamsImpl } from './mediaStreams';\nimport { uuid, extend } from './utils';\nimport { uuidKey, defaultMediaConstraints, defaultLogLevel, defaultSipErrorCodes, defaultStunServers, } from './constants';\nimport { defaultSessionDescriptionFactory, } from './sessionDescriptionHandler';\nimport pkg from '../package.json';\nconst version = pkg.version;\nconst defaultWebPhoneOptions = {\n    autoStop: true,\n    builtinEnabled: true,\n    earlyMedia: false,\n    enableDefaultModifiers: true,\n    enableDscp: false,\n    iceTransportPolicy: 'all',\n    maxReconnectionAttemptsNoBackup: 15,\n    maxReconnectionAttemptsWithBackup: 10,\n    mediaConstraints: defaultMediaConstraints,\n    modifiers: [],\n    // FIXME: This should be in seconds since every other config is in seconds\n    qosCollectInterval: 5000,\n    reconnectionTimeoutNoBackup: 5,\n    reconnectionTimeoutWithBackup: 4,\n    transportServers: [],\n    turnServers: [],\n    uuid: uuid(),\n    uuidKey,\n};\n/**\n * WebPhone class to initiate WebRTC calls\n */\nexport default class WebPhone {\n    /** WebPhone version */\n    static version = version;\n    /** Utility function to generate uuid */\n    static uuid = uuid;\n    /** Utility function to extend object */\n    static extend = extend;\n    static MediaStreams = MediaStreams;\n    static MediaStreamsImpl = MediaStreamsImpl;\n    /** Sip Info received from the registration endpoint */\n    sipInfo;\n    /** Key that will be used to save uuid in localStorage */\n    uuidKey;\n    /** Name used in user agent string */\n    appName;\n    /** Version used in user agent string */\n    appVersion;\n    /** WebPhoneUserAgent instance */\n    userAgent;\n    /**\n     * TODO: include 'WebPhone' for all apps other than Chrome and Glip\n     * TODO: parse wsservers from new api spec\n     */\n    // eslint-disable-next-line complexity\n    constructor(registrationData = {}, _options = {}) {\n        const options = { ...defaultWebPhoneOptions, ..._options };\n        this.sipInfo = registrationData.sipInfo;\n        if (Array.isArray(this.sipInfo)) {\n            this.sipInfo = this.sipInfo[0];\n        }\n        this.uuidKey = options.uuidKey;\n        this.appName = options.appName;\n        this.appVersion = options.appVersion;\n        const id = options.uuid;\n        localStorage.setItem(this.uuidKey, id);\n        const uaMatch = navigator.userAgent.match(/\\((.*?)\\)/);\n        const appClientOs = uaMatch === null ? '' : uaMatch[1].replace(/[^a-zA-Z0-9.:_]+/g, '-');\n        const userAgentString = (this.appName ? this.appName + (this.appVersion ? '/' + this.appVersion : '') + ' ' : '') +\n            (appClientOs ? appClientOs : '') +\n            ` RCWEBPHONE/${WebPhone.version}`;\n        const modifiers = options.modifiers;\n        if (!options.enableDefaultModifiers) {\n            modifiers.push(Web.stripG722);\n            modifiers.push(Web.stripTcpCandidates);\n        }\n        if (options.enableMidLinesInSDP) {\n            modifiers.push(Web.addMidLines);\n        }\n        const sdpSemantics = options.enablePlanB ? 'plan-b' : 'unified-plan';\n        const stunServers = options.stunServers || defaultStunServers;\n        const iceTransportPolicy = options.iceTransportPolicy;\n        let iceServers = [];\n        if (options.enableTurnServers) {\n            iceServers = options.turnServers.map((url) => ({ urls: url }));\n            options.iceCheckingTimeout = options.iceCheckingTimeout || 2000;\n        }\n        iceServers = [\n            ...iceServers,\n            ...stunServers.map((_url) => {\n                const url = !/^(stun:)/.test(_url) ? `stun:${_url}` : _url;\n                return { urls: url };\n            }),\n        ];\n        const sessionDescriptionHandlerFactoryOptions = options.sessionDescriptionHandlerFactoryOptions || {\n            iceGatheringTimeout: options.iceCheckingTimeout || 500,\n            enableDscp: options.enableDscp,\n            peerConnectionConfiguration: {\n                iceServers,\n                iceTransportPolicy,\n                sdpSemantics,\n            },\n        };\n        sessionDescriptionHandlerFactoryOptions.enableDscp = !!options.enableDscp;\n        options.modifiers = modifiers;\n        const browserUa = navigator.userAgent.toLowerCase();\n        if (browserUa.includes('firefox') && !browserUa.includes('chrome')) {\n            // FIXME: alwaysAcquireMediaFirst has been removed from SIP.js. Is it the same as earlyMedia?\n            options.earlyMedia = true;\n        }\n        const sessionDescriptionHandlerFactory = options.sessionDescriptionHandlerFactory || defaultSessionDescriptionFactory;\n        const sipErrorCodes = registrationData.sipErrorCodes?.length\n            ? registrationData.sipErrorCodes\n            : defaultSipErrorCodes;\n        let reconnectionTimeout = options.reconnectionTimeoutWithBackup;\n        let maxReconnectionAttempts = options.maxReconnectionAttemptsWithBackup;\n        if (this.sipInfo.outboundProxy && this.sipInfo.transport) {\n            options.transportServers.push({\n                uri: this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxy,\n            });\n            reconnectionTimeout = options.reconnectionTimeoutNoBackup;\n            maxReconnectionAttempts = options.maxReconnectionAttemptsNoBackup;\n        }\n        if (this.sipInfo.outboundProxyBackup && this.sipInfo.transport) {\n            options.transportServers.push({\n                uri: this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxyBackup,\n            });\n        }\n        options.reconnectionTimeout = options.reconnectionTimeout || reconnectionTimeout;\n        options.maxReconnectionAttempts = options.maxReconnectionAttempts || maxReconnectionAttempts;\n        const transportServer = options.transportServers.length ? options.transportServers[0].uri : '';\n        const configuration = {\n            uri: UserAgent.makeURI(`sip:${this.sipInfo.username}@${this.sipInfo.domain}`),\n            transportOptions: {\n                server: transportServer,\n                traceSip: true,\n                connectionTimeout: 5,\n                keepAliveDebounce: options.keepAliveDebounce,\n                keepAliveInterval: options.keepAliveInterval,\n            },\n            // WebPhoneTransport will handle reconnection.\n            reconnectionAttempts: 0,\n            authorizationUsername: this.sipInfo.authorizationId,\n            authorizationPassword: this.sipInfo.password,\n            logLevel: LogLevels[options.logLevel] || defaultLogLevel,\n            logBuiltinEnabled: options.builtinEnabled,\n            logConnector: options.connector || undefined,\n            userAgentString,\n            sessionDescriptionHandlerFactoryOptions,\n            sessionDescriptionHandlerFactory,\n            allowLegacyNotifications: true,\n        };\n        options.sipErrorCodes = sipErrorCodes;\n        options.switchBackInterval = this.sipInfo.switchBackInterval;\n        this.userAgent = createWebPhoneUserAgent(configuration, this.sipInfo, options, id);\n    }\n}\n"],"names":[],"sourceRoot":""}